<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexo Dash - Laboratório Virtual de Simulação</title>
    <meta name="description" content="Ambiente de aprendizado imersivo para desenvolvimento Dash/Python">
    
    <!-- Estilos CSS principais -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            overflow: hidden;
            height: 100vh;
            position: relative;
        }

        /* Canvas 3D que ocupará toda a tela */
        #threejs-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Tela de carregamento */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 50%, #0f0f23 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #00ff88;
            text-align: center;
        }

        .loading-logo {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px #00ff88;
            animation: pulse 2s ease-in-out infinite;
        }

        .loading-text {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            opacity: 0.8;
        }

        .loading-progress {
            width: 300px;
            height: 4px;
            background: rgba(0, 255, 136, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #00ff88;
        }

        .loading-status {
            font-size: 1rem;
            opacity: 0.6;
            min-height: 1.5rem;
        }

        /* Painéis holográficos (inicialmente ocultos) */
        .holographic-panel {
            position: fixed;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            padding: 2rem;
            color: #00ff88;
            font-size: 1.1rem;
            line-height: 1.6;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.2);
            z-index: 100;
            display: none;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
        }

        .panel-title {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: center;
            text-shadow: 0 0 10px #00ff88;
        }

        .panel-content {
            margin-bottom: 1.5rem;
        }

        .panel-actions {
            text-align: center;
        }

        .holographic-button {
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            padding: 0.8rem 2rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.3s ease;
            margin: 0.5rem;
        }

        .holographic-button:hover {
            background: rgba(0, 255, 136, 0.4);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            transform: translateY(-2px);
        }

        /* Responsividade */
        @media (max-width: 1024px) {
            .holographic-panel {
                max-width: 500px;
                right: 15px;
                font-size: 1rem;
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .loading-logo {
                font-size: 2rem;
            }
            
            .loading-text {
                font-size: 1.2rem;
            }
            
            .loading-progress {
                width: 250px;
            }
            
            .holographic-panel {
                left: 10px;
                right: 10px;
                top: 20px;
                bottom: 20px;
                max-width: none;
                max-height: none;
                padding: 1.5rem;
                font-size: 1rem;
                transform: none;
                overflow-y: auto;
            }
            
            .panel-title {
                font-size: 1.5rem;
            }
        }

        @media (max-width: 480px) {
            .loading-logo {
                font-size: 1.5rem;
            }
            
            .loading-text {
                font-size: 1rem;
            }
            
            .loading-progress {
                width: 200px;
            }
            
            .holographic-panel {
                padding: 1rem;
                font-size: 0.9rem;
                left: 5px;
                right: 5px;
                top: 10px;
                bottom: 10px;
            }
            
            .panel-title {
                font-size: 1.3rem;
            }
            
            .holographic-button {
                padding: 0.6rem 1.5rem;
                font-size: 0.9rem;
                margin: 0.3rem;
            }
        }

        /* Animações */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        @keyframes glow {
            0%, 100% { text-shadow: 0 0 20px #00ff88; }
            50% { text-shadow: 0 0 30px #00ff88, 0 0 40px #00ccff; }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideInRight {
            from { 
                opacity: 0; 
                transform: translateX(100px) translateY(-50%); 
            }
            to { 
                opacity: 1; 
                transform: translateX(0) translateY(-50%); 
            }
        }

        .glow-animation {
            animation: glow 3s ease-in-out infinite;
        }

        .holographic-panel {
            animation: slideInRight 0.5s ease-out;
        }

        /* Estilos para código */
        .code-block {
            background: #1a1a1a;
            padding: 1rem;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 1rem 0;
            border-left: 4px solid #00ff88;
            overflow-x: auto;
        }

        .code-block code {
            color: #00ff88;
        }

        /* Estilos para links */
        .holographic-panel a {
            color: #00ccff;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .holographic-panel a:hover {
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }

        /* Badges de status */
        .status-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            border-radius: 15px;
            font-size: 0.8rem;
            margin: 0.2rem;
        }

        /* Listas estilizadas */
        .holographic-panel ul {
            padding-left: 1.5rem;
        }

        .holographic-panel li {
            margin-bottom: 0.5rem;
            position: relative;
        }

        .holographic-panel li::marker {
            color: #00ff88;
        }

        /* Destacar elementos importantes */
        .highlight-box {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            padding: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
        }

        /* Scroll customizado para o painel */
        .holographic-panel::-webkit-scrollbar {
            width: 8px;
        }

        .holographic-panel::-webkit-scrollbar-track {
            background: rgba(0, 255, 136, 0.1);
            border-radius: 4px;
        }

        .holographic-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 136, 0.5);
            border-radius: 4px;
        }

        .holographic-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 136, 0.7);
        }

        /* Numeração de passos */
        .step-number {
            display: inline-block;
            width: 30px;
            height: 30px;
            background: #00ff88;
            color: #000;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            margin-right: 0.5rem;
        }
    </style>
</head>
<body>
    <!-- Tela de Carregamento -->
    <div id="loading-screen">
        <div class="loading-logo">NEXO DASH</div>
        <div class="loading-text">Carregando Laboratório Virtual...</div>
        <div class="loading-progress">
            <div class="loading-bar" id="loading-bar"></div>
        </div>
        <div class="loading-status" id="loading-status">Inicializando sistema...</div>
    </div>

    <!-- Container principal para three.js -->
    <div id="threejs-container"></div>

    <!-- Painel Holográfico (inicialmente oculto) -->
    <div class="holographic-panel" id="main-panel">
        <div class="panel-title" id="panel-title">Bem-vindo ao Nexo Dash</div>
        <div class="panel-content" id="panel-content">
            Inicializando ambiente de simulação...
        </div>
        <div class="panel-actions" id="panel-actions">
            <button class="holographic-button" id="continue-btn" onclick="nextStep()">
                Continuar
            </button>
        </div>
    </div>

    <!-- Inclusão das bibliotecas principais via CDN -->
    <!-- Three.js para renderização 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <!-- Pyodide para execução de Python no navegador -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    
    <!-- AutoTranslate.js v2.0.1 para internacionalização -->
    <script src="https://cdn.jsdelivr.net/npm/auto-translate@2.0.1/dist/index.min.js"></script>

    <!-- Script principal da aplicação -->
    <script>
        // Estado global da aplicação
        const AppState = {
            pyodide: null,
            currentModule: 0,
            isInitialized: false,
            scene: null,
            camera: null,
            renderer: null,
            controls: null,
            animationId: null
        };

        // Configuração do sistema de carregamento
        const LoadingSystem = {
            currentStep: 0,
            totalSteps: 5,
            steps: [
                'Inicializando sistema...',
                'Carregando three.js...',
                'Configurando ambiente 3D...',
                'Inicializando Pyodide...',
                'Carregando pacotes Python...'
            ],

            updateProgress(step, message = null) {
                this.currentStep = step;
                const progress = (step / this.totalSteps) * 100;
                const progressBar = document.getElementById('loading-bar');
                const statusText = document.getElementById('loading-status');
                
                progressBar.style.width = progress + '%';
                statusText.textContent = message || this.steps[step] || 'Carregando...';
            },

            hide() {
                const loadingScreen = document.getElementById('loading-screen');
                loadingScreen.style.opacity = '0';
                loadingScreen.style.transition = 'opacity 1s ease-out';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 1000);
            }
        };

        // Sistema de renderização 3D
        const ThreeJSSystem = {
            init() {
                return new Promise((resolve) => {
                    try {
                        LoadingSystem.updateProgress(1, 'Carregando three.js...');
                        
                        // Criar cena
                        AppState.scene = new THREE.Scene();
                        AppState.scene.background = new THREE.Color(0x0a0a1a);

                        // Configurar câmera
                        const aspect = window.innerWidth / window.innerHeight;
                        AppState.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                        AppState.camera.position.set(0, 5, 10);

                        // Criar renderizador
                        AppState.renderer = new THREE.WebGLRenderer({ antialias: true });
                        AppState.renderer.setSize(window.innerWidth, window.innerHeight);
                        AppState.renderer.shadowMap.enabled = true;
                        AppState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                        // Adicionar renderizador ao DOM
                        const container = document.getElementById('threejs-container');
                        container.appendChild(AppState.renderer.domElement);

                        LoadingSystem.updateProgress(2, 'Configurando ambiente 3D...');

                        // Configurar iluminação
                        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                        AppState.scene.add(ambientLight);

                        const directionalLight = new THREE.DirectionalLight(0x00ff88, 1);
                        directionalLight.position.set(10, 10, 5);
                        directionalLight.castShadow = true;
                        directionalLight.shadow.mapSize.width = 2048;
                        directionalLight.shadow.mapSize.height = 2048;
                        AppState.scene.add(directionalLight);

                        // Carregar modelo 3D da Dra. Turing PRIMEIRO
                        this.loadDrTuring();
                        
                        // Se o modelo falhar, criar placeholder imediatamente
                        setTimeout(() => {
                            if (!AppState.drTuring) {
                                console.log('Modelo da Dra. Turing não carregou, criando placeholder...');
                                this.createDrTuringPlaceholder();
                            }
                        }, 3000); // 3 segundos de timeout

                        // Configurar controles de órbita
                        AppState.controls = new THREE.OrbitControls(AppState.camera, AppState.renderer.domElement);
                        AppState.controls.enableDamping = true;
                        AppState.controls.dampingFactor = 0.05;
                        AppState.controls.maxPolarAngle = Math.PI / 2;

                        // Criar geometria inicial (plataforma do laboratório)
                        this.createLaboratoryPlatform();
                        
                        // Configurar responsividade
                        window.addEventListener('resize', this.onWindowResize.bind(this));

                        // Iniciar loop de animação
                        this.animate();

                        resolve();
                    } catch (error) {
                        console.error('Erro ao inicializar Three.js:', error);
                        resolve(); // Continuar mesmo com erro
                    }
                });
            },

            loadDrTuring() {
                LoadingSystem.updateProgress(3, 'Carregando Dra. Ana Turing...');
                
                // Inicializar GLTFLoader
                const loader = new THREE.GLTFLoader();
                
                // Carregar modelo 3D da Dra. Turing
                loader.load(
                    './assets/Pbr/base_basic_pbr.glb',
                    (gltf) => {
                        console.log('Modelo da Dra. Turing carregado com sucesso!');
                        
                        const drTuring = gltf.scene;
                        
                        // Posicionar próximo ao laboratório - lado esquerdo em posição mais central
                        drTuring.position.set(-8, 0, 5);
                        drTuring.scale.set(2.5, 2.5, 2.5); // Tamanho maior para ser mais visível
                        drTuring.rotation.y = Math.PI / 4; // Girar para olhar em direção ao centro
                        
                        // Configurar materiais com cores realistas para um personagem humano
                        drTuring.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                if (child.material) {
                                    // Aplicar cores realistas baseadas no nome do material ou posição
                                    if (child.name.toLowerCase().includes('skin') || 
                                        child.material.name?.toLowerCase().includes('skin') ||
                                        child.name.toLowerCase().includes('head') ||
                                        child.name.toLowerCase().includes('face')) {
                                        // Cor de pele realista
                                        child.material.color = new THREE.Color(0xffdbac);
                                        child.material.transparent = false;
                                        child.material.opacity = 1.0;
                                        child.material.emissive = new THREE.Color(0x000000);
                                        child.material.emissiveIntensity = 0;
                                    } else if (child.name.toLowerCase().includes('hair') ||
                                               child.material.name?.toLowerCase().includes('hair')) {
                                        // Cabelo castanho escuro
                                        child.material.color = new THREE.Color(0x2d1b0e);
                                        child.material.transparent = false;
                                        child.material.opacity = 1.0;
                                        child.material.emissive = new THREE.Color(0x000000);
                                        child.material.emissiveIntensity = 0;
                                    } else if (child.name.toLowerCase().includes('cloth') ||
                                               child.name.toLowerCase().includes('shirt') ||
                                               child.name.toLowerCase().includes('dress') ||
                                               child.material.name?.toLowerCase().includes('cloth')) {
                                        // Jaleco branco de laboratório
                                        child.material.color = new THREE.Color(0xf8f8ff);
                                        child.material.transparent = false;
                                        child.material.opacity = 1.0;
                                        child.material.emissive = new THREE.Color(0x222244);
                                        child.material.emissiveIntensity = 0.1; // Leve brilho futurista
                                    } else if (child.name.toLowerCase().includes('eye') ||
                                               child.material.name?.toLowerCase().includes('eye')) {
                                        // Olhos realistas
                                        child.material.color = new THREE.Color(0x4a90e2);
                                        child.material.transparent = false;
                                        child.material.opacity = 1.0;
                                        child.material.emissive = new THREE.Color(0x001122);
                                        child.material.emissiveIntensity = 0.2;
                                    } else {
                                        // Material padrão com leve toque futurista
                                        child.material.color = new THREE.Color(0xeeeeee);
                                        child.material.transparent = false;
                                        child.material.opacity = 1.0;
                                        child.material.emissive = new THREE.Color(0x002244);
                                        child.material.emissiveIntensity = 0.05;
                                    }
                                    
                                    // Propriedades gerais para aparência mais realista
                                    child.material.metalness = 0.1;
                                    child.material.roughness = 0.7;
                                }
                            }
                        });
                                  // Adicionar à cena
                AppState.scene.add(drTuring);
                AppState.drTuring = drTuring;
                
                // Sistema de animações da Dra. Turing
                this.setupDrTuringAnimations(drTuring);
                
                // Sistema de fala 3D
                this.setupDrTuringSpeech3D(drTuring);
                
                // Adicionar iluminação especial para a Dra. Turing
                this.addDrTuringLighting(drTuring);
                
                // Mostrar mensagem inicial com animação de entrada
                setTimeout(() => {
                    this.drTuringSpeak3D(`Olá! Bem-vindo ao Nexo Dash! Sou a Dra. Ana Turing, sua mentora nesta jornada fascinante. Juntos, construiremos um dashboard completo para análise de doenças cardíacas usando Python e Dash. Está pronto para esta missão?`);
                    
                    // Adicionar gesto de boas-vindas
                    setTimeout(() => {
                        if (AppState.drTuringAnimations && AppState.drTuringAnimations.performGesture) {
                            AppState.drTuringAnimations.performGesture('wave');
                        }
                    }, 1000);
                }, 2000);
                        
                        LoadingSystem.updateProgress(4, 'Dra. Turing online!');
                    },
                    (progress) => {
                        console.log('Progresso do carregamento:', (progress.loaded / progress.total * 100) + '%');
                    },
                    (error) => {
                        console.error('Erro ao carregar modelo da Dra. Turing:', error);
                        // Criar um placeholder visual mais realista se o modelo falhar
                        this.createDrTuringPlaceholder();
                    }
                );
            },

            setupDrTuringAnimations(model) {
                // Sistema de animações humanizadas da Dra. Turing
                AppState.drTuringAnimations = {
                    idleAnimation: null,
                    speakingAnimation: null,
                    walkAnimation: null,
                    gestureAnimation: null,
                    isSpeaking: false,
                    isWalking: false,
                    isGesturing: false,
                    breathingPhase: 0,
                    blinkTimer: 0,
                    nextBlinkTime: Math.random() * 3000 + 2000,
                    basePosition: { x: model.position.x, y: model.position.y, z: model.position.z },
                    baseRotation: { x: model.rotation.x, y: model.rotation.y, z: model.rotation.z }
                };

                // Partes do corpo para animação (se disponível no modelo GLTF)
                const bodyParts = {
                    head: model.getObjectByName('Head') || model.getObjectByName('head') || null,
                    leftArm: model.getObjectByName('LeftArm') || model.getObjectByName('left_arm') || null,
                    rightArm: model.getObjectByName('RightArm') || model.getObjectByName('right_arm') || null,
                    spine: model.getObjectByName('Spine') || model.getObjectByName('spine') || null,
                    eyes: model.getObjectByName('Eyes') || model.getObjectByName('eyes') || null
                };

                // Animação Idle realista (respiração, piscar, micro-movimentos)
                const startIdleAnimation = () => {
                    const animate = () => {
                        if (!AppState.drTuringAnimations.isSpeaking && !AppState.drTuringAnimations.isWalking) {
                            const time = Date.now() * 0.001;
                            const basePos = AppState.drTuringAnimations.basePosition;
                            const baseRot = AppState.drTuringAnimations.baseRotation;

                            // Respiração natural (ciclo de 4 segundos)
                            const breathingCycle = Math.sin(time * 0.5) * 0.03;
                            model.position.y = basePos.y + breathingCycle;
                            
                            // Expansão sutil do peito durante respiração
                            if (bodyParts.spine) {
                                bodyParts.spine.scale.y = 1 + breathingCycle * 0.1;
                            }

                            // Micro-movimentos naturais da cabeça
                            const headSway = Math.sin(time * 0.3) * 0.05 + Math.sin(time * 0.7) * 0.02;
                            const headNod = Math.sin(time * 0.2) * 0.03;
                            
                            if (bodyParts.head) {
                                bodyParts.head.rotation.y = headSway;
                                bodyParts.head.rotation.x = headNod;
                            } else {
                                // Aplicar no modelo inteiro se não há cabeça separada
                                model.rotation.y = baseRot.y + headSway;
                                model.rotation.x = baseRot.x + headNod;
                            }

                            // Sistema de piscar realista
                            AppState.drTuringAnimations.blinkTimer += 16; // ~60fps
                            if (AppState.drTuringAnimations.blinkTimer >= AppState.drTuringAnimations.nextBlinkTime) {
                                this.performBlink();
                                AppState.drTuringAnimations.blinkTimer = 0;
                                AppState.drTuringAnimations.nextBlinkTime = Math.random() * 4000 + 1500; // 1.5-5.5s
                            }

                            // Peso corporal shifting sutil
                            const weightShift = Math.sin(time * 0.15) * 0.01;
                            model.rotation.z = baseRot.z + weightShift;

                            // Ocasionalmente olhar para pontos de interesse
                            if (Math.random() < 0.001) { // 0.1% chance por frame
                                this.performCasualLook();
                            }
                        }
                        
                        AppState.drTuringAnimations.idleAnimation = requestAnimationFrame(animate);
                    };
                    
                    animate();
                };

                // Animação de fala humanizada
                const startSpeakingAnimation = () => {
                    const animate = () => {
                        if (AppState.drTuringAnimations.isSpeaking) {
                            const time = Date.now() * 0.001;
                            const basePos = AppState.drTuringAnimations.basePosition;
                            const baseRot = AppState.drTuringAnimations.baseRotation;

                            // Respiração mais pronunciada durante fala
                            const speakingBreath = Math.sin(time * 2) * 0.08;
                            model.position.y = basePos.y + speakingBreath;

                            // Movimentos expressivos da cabeça
                            const headExpression = Math.sin(time * 1.5) * 0.15;
                            const headEmphasis = Math.sin(time * 0.8) * 0.08;

                            if (bodyParts.head) {
                                bodyParts.head.rotation.y = headExpression;
                                bodyParts.head.rotation.x = headEmphasis;
                            } else {
                                model.rotation.y = baseRot.y + headExpression;
                                model.rotation.x = baseRot.x + headEmphasis;
                            }

                            // Gestos naturais com as mãos
                            if (bodyParts.leftArm && bodyParts.rightArm) {
                                const gesturePhase = time * 0.7;
                                bodyParts.leftArm.rotation.z = Math.sin(gesturePhase) * 0.3;
                                bodyParts.rightArm.rotation.z = Math.sin(gesturePhase + Math.PI) * 0.25;
                                bodyParts.leftArm.rotation.x = Math.sin(gesturePhase * 0.5) * 0.2;
                                bodyParts.rightArm.rotation.x = Math.sin(gesturePhase * 0.5 + Math.PI/3) * 0.15;
                            }

                            // Movimento corporal engajado
                            const bodyEngagement = Math.sin(time * 1.2) * 0.03;
                            model.rotation.z = baseRot.z + bodyEngagement;

                            // Piscar mais frequente durante fala (mais expressivo)
                            if (Math.random() < 0.003) { // Mais frequente
                                this.performBlink();
                            }
                            
                            AppState.drTuringAnimations.speakingAnimation = requestAnimationFrame(animate);
                        }
                    };
                    
                    animate();
                };

                // Animação de caminhada humanizada
                const walkToPosition = (targetX, targetZ, duration = 3000) => {
                    AppState.drTuringAnimations.isWalking = true;
                    
                    const startPos = { 
                        x: model.position.x, 
                        y: AppState.drTuringAnimations.basePosition.y,
                        z: model.position.z 
                    };
                    const startTime = Date.now();
                    
                    // Calcular direção e distância
                    const deltaX = targetX - startPos.x;
                    const deltaZ = targetZ - startPos.z;
                    const distance = Math.sqrt(deltaX * deltaX + deltaZ * deltaZ);
                    const direction = Math.atan2(deltaZ, deltaX);
                    
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Easing natural para aceleração/desaceleração
                        const easedProgress = this.humanizedEasing(progress);
                        
                        // Atualizar posição principal
                        model.position.x = startPos.x + (deltaX * easedProgress);
                        model.position.z = startPos.z + (deltaZ * easedProgress);
                        
                        // Ciclo de caminhada natural
                        const walkSpeed = (distance / duration) * 1000; // pixels/segundo
                        const stepFrequency = Math.max(1.5, walkSpeed * 0.001); // Ajustar frequência baseada na velocidade
                        const walkCycle = elapsed * 0.001 * stepFrequency;
                        
                        // Movimento vertical da caminhada (bounce natural)
                        const stepHeight = Math.abs(Math.sin(walkCycle * Math.PI)) * 0.15;
                        model.position.y = startPos.y + stepHeight;
                        
                        // Rotação do corpo durante caminhada
                        model.rotation.y = direction + Math.PI / 2;
                        
                        // Balanço natural do corpo
                        const bodyRock = Math.sin(walkCycle * Math.PI) * 0.08;
                        model.rotation.z = bodyRock;
                        
                        // Balanço dos braços (se disponível)
                        if (bodyParts.leftArm && bodyParts.rightArm) {
                            const armSwing = walkCycle * Math.PI;
                            bodyParts.leftArm.rotation.x = Math.sin(armSwing) * 0.5;
                            bodyParts.rightArm.rotation.x = Math.sin(armSwing + Math.PI) * 0.5;
                        }
                        
                        // Movimento da cabeça durante caminhada
                        if (bodyParts.head) {
                            bodyParts.head.rotation.y = Math.sin(walkCycle * Math.PI * 0.5) * 0.1;
                            bodyParts.head.rotation.x = -0.05; // Olhar ligeiramente para frente
                        }
                        
                        if (progress < 1) {
                            AppState.drTuringAnimations.walkAnimation = requestAnimationFrame(animate);
                        } else {
                            // Finalizar caminhada suavemente
                            AppState.drTuringAnimations.isWalking = false;
                            model.position.y = AppState.drTuringAnimations.basePosition.y;
                            model.rotation.y = AppState.drTuringAnimations.baseRotation.y;
                            model.rotation.z = AppState.drTuringAnimations.baseRotation.z;
                            
                            // Reset dos braços
                            if (bodyParts.leftArm && bodyParts.rightArm) {
                                bodyParts.leftArm.rotation.x = 0;
                                bodyParts.rightArm.rotation.x = 0;
                            }
                        }
                    };
                    
                    animate();
                };

                // Função de easing humanizado
                this.humanizedEasing = (t) => {
                    // Curva que simula aceleração e desaceleração humana natural
                    if (t < 0.1) {
                        // Aceleração inicial gradual
                        return t * t * 10;
                    } else if (t > 0.9) {
                        // Desaceleração final suave
                        const remaining = (t - 0.9) / 0.1;
                        return 0.81 + (1 - 0.81) * (1 - (1 - remaining) * (1 - remaining));
                    } else {
                        // Movimento constante no meio
                        return 0.1 + (t - 0.1) * 0.9;
                    }
                };

                // Sistema de piscar realista
                this.performBlink = () => {
                    if (bodyParts.eyes) {
                        const originalScale = bodyParts.eyes.scale.y;
                        
                        // Animação rápida de fechar e abrir olhos
                        const blinkDuration = 150;
                        const startTime = Date.now();
                        
                        const animateBlink = () => {
                            const elapsed = Date.now() - startTime;
                            const progress = elapsed / blinkDuration;
                            
                            if (progress < 0.5) {
                                // Fechar olhos
                                bodyParts.eyes.scale.y = originalScale * (1 - progress * 2);
                            } else {
                                // Abrir olhos
                                bodyParts.eyes.scale.y = originalScale * ((progress - 0.5) * 2);
                            }
                            
                            if (progress < 1) {
                                requestAnimationFrame(animateBlink);
                            } else {
                                bodyParts.eyes.scale.y = originalScale;
                            }
                        };
                        
                        animateBlink();
                    }
                };

                // Olhadas casuais para pontos de interesse
                this.performCasualLook = () => {
                    if (bodyParts.head && !AppState.drTuringAnimations.isSpeaking) {
                        const currentRotY = bodyParts.head.rotation.y;
                        const lookDirection = (Math.random() - 0.5) * 0.5; // -0.25 a 0.25 radianos
                        const lookDuration = 1000 + Math.random() * 2000; // 1-3 segundos
                        
                        const startTime = Date.now();
                        const startRotation = currentRotY;
                        
                        const animateLook = () => {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / lookDuration, 1);
                            
                            let easeProgress;
                            if (progress < 0.3) {
                                // Mover para direção
                                easeProgress = progress / 0.3;
                                bodyParts.head.rotation.y = startRotation + lookDirection * easeProgress;
                            } else if (progress < 0.7) {
                                // Manter olhar
                                bodyParts.head.rotation.y = startRotation + lookDirection;
                            } else {
                                // Voltar ao centro
                                easeProgress = (progress - 0.7) / 0.3;
                                bodyParts.head.rotation.y = startRotation + lookDirection * (1 - easeProgress);
                            }
                            
                            if (progress < 1) {
                                requestAnimationFrame(animateLook);
                            }
                        };
                        
                        animateLook();
                    }
                };

                // Métodos públicos melhorados
                AppState.drTuringAnimations.startSpeaking = () => {
                    AppState.drTuringAnimations.isSpeaking = true;
                    startSpeakingAnimation();
                };

                AppState.drTuringAnimations.stopSpeaking = () => {
                    AppState.drTuringAnimations.isSpeaking = false;
                    if (AppState.drTuringAnimations.speakingAnimation) {
                        cancelAnimationFrame(AppState.drTuringAnimations.speakingAnimation);
                    }
                };

                AppState.drTuringAnimations.walkTo = walkToPosition;

                // Adicionar gesture system melhorado
                AppState.drTuringAnimations.performGesture = (gestureType = 'point') => {
                    if (AppState.drTuringAnimations.isGesturing) return;
                    
                    AppState.drTuringAnimations.isGesturing = true;
                    
                    const rightArm = bodyParts.rightArm || model.getObjectByName('right_arm');
                    const leftArm = bodyParts.leftArm || model.getObjectByName('left_arm');
                    const head = bodyParts.head || model.getObjectByName('head');
                    
                    switch(gestureType) {
                        case 'point':
                            this.performPointGesture(rightArm);
                            break;
                        case 'wave':
                            this.performWaveGesture(rightArm);
                            break;
                        case 'welcome':
                            this.performWelcomeGesture(leftArm, rightArm);
                            break;
                        case 'explain':
                            this.performExplainGesture(leftArm, rightArm, head);
                            break;
                        case 'think':
                            this.performThinkGesture(rightArm, head);
                            break;
                        case 'encourage':
                            this.performEncourageGesture(leftArm, rightArm);
                            break;
                        default:
                            this.performPointGesture(rightArm);
                    }
                };

                // Gestos específicos com animações naturais
                this.performPointGesture = (arm) => {
                    if (!arm) return this.finishGesture();
                    
                    const originalRotation = { x: arm.rotation.x, y: arm.rotation.y, z: arm.rotation.z };
                    const gestureDuration = 2500;
                    const startTime = Date.now();
                    
                    const animateGesture = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / gestureDuration, 1);
                        
                        if (progress < 0.3) {
                            // Levantar braço
                            const raiseProgress = progress / 0.3;
                            arm.rotation.x = originalRotation.x - raiseProgress * 0.9;
                            arm.rotation.z = originalRotation.z + raiseProgress * 0.6;
                        } else if (progress < 0.7) {
                            // Manter posição com micro-ajustes
                            const holdPhase = (progress - 0.3) / 0.4;
                            const microMovement = Math.sin(holdPhase * Math.PI * 4) * 0.05;
                            arm.rotation.x = originalRotation.x - 0.9 + microMovement;
                            arm.rotation.z = originalRotation.z + 0.6;
                        } else {
                            // Baixar braço suavemente
                            const lowerProgress = (progress - 0.7) / 0.3;
                            const easedLower = 1 - Math.pow(1 - lowerProgress, 3);
                            arm.rotation.x = (originalRotation.x - 0.9) + easedLower * 0.9;
                            arm.rotation.z = (originalRotation.z + 0.6) - easedLower * 0.6;
                        }
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateGesture);
                        } else {
                            arm.rotation.x = originalRotation.x;
                            arm.rotation.z = originalRotation.z;
                            this.finishGesture();
                        }
                    };
                    
                    animateGesture();
                };

                this.performWaveGesture = (arm) => {
                    if (!arm) return this.finishGesture();
                    
                    const originalRotation = { x: arm.rotation.x, y: arm.rotation.y, z: arm.rotation.z };
                    const gestureDuration = 3000;
                    const startTime = Date.now();
                    
                    const animateGesture = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / gestureDuration, 1);
                        
                        if (progress < 0.2) {
                            // Levantar braço
                            const raiseProgress = progress / 0.2;
                            arm.rotation.x = originalRotation.x - raiseProgress * 1.2;
                            arm.rotation.z = originalRotation.z + raiseProgress * 0.8;
                        } else if (progress < 0.8) {
                            // Acenar (movimento de vai-e-vem)
                            const wavePhase = (progress - 0.2) / 0.6;
                            const waveMotion = Math.sin(wavePhase * Math.PI * 6) * 0.4;
                            arm.rotation.x = originalRotation.x - 1.2;
                            arm.rotation.z = originalRotation.z + 0.8 + waveMotion;
                        } else {
                            // Baixar braço
                            const lowerProgress = (progress - 0.8) / 0.2;
                            const easedLower = 1 - Math.pow(1 - lowerProgress, 3);
                            arm.rotation.x = (originalRotation.x - 1.2) + easedLower * 1.2;
                            arm.rotation.z = (originalRotation.z + 0.8) - easedLower * 0.8;
                        }
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateGesture);
                        } else {
                            arm.rotation.x = originalRotation.x;
                            arm.rotation.z = originalRotation.z;
                            this.finishGesture();
                        }
                    };
                    
                    animateGesture();
                };

                this.performWelcomeGesture = (leftArm, rightArm) => {
                    if (!leftArm || !rightArm) return this.finishGesture();
                    
                    const originalLeft = { x: leftArm.rotation.x, z: leftArm.rotation.z };
                    const originalRight = { x: rightArm.rotation.x, z: rightArm.rotation.z };
                    const gestureDuration = 4000;
                    const startTime = Date.now();
                    
                    const animateGesture = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / gestureDuration, 1);
                        
                        if (progress < 0.3) {
                            // Abrir braços
                            const openProgress = progress / 0.3;
                            leftArm.rotation.x = originalLeft.x - openProgress * 0.8;
                            leftArm.rotation.z = originalLeft.z - openProgress * 0.6;
                            rightArm.rotation.x = originalRight.x - openProgress * 0.8;
                            rightArm.rotation.z = originalRight.z + openProgress * 0.6;
                        } else if (progress < 0.7) {
                            // Manter posição aberta
                            leftArm.rotation.x = originalLeft.x - 0.8;
                            leftArm.rotation.z = originalLeft.z - 0.6;
                            rightArm.rotation.x = originalRight.x - 0.8;
                            rightArm.rotation.z = originalRight.z + 0.6;
                        } else {
                            // Fechar braços
                            const closeProgress = (progress - 0.7) / 0.3;
                            const easedClose = 1 - Math.pow(1 - closeProgress, 3);
                            leftArm.rotation.x = (originalLeft.x - 0.8) + easedClose * 0.8;
                            leftArm.rotation.z = (originalLeft.z - 0.6) + easedClose * 0.6;
                            rightArm.rotation.x = (originalRight.x - 0.8) + easedClose * 0.8;
                            rightArm.rotation.z = (originalRight.z + 0.6) - easedClose * 0.6;
                        }
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateGesture);
                        } else {
                            leftArm.rotation.x = originalLeft.x;
                            leftArm.rotation.z = originalLeft.z;
                            rightArm.rotation.x = originalRight.x;
                            rightArm.rotation.z = originalRight.z;
                            this.finishGesture();
                        }
                    };
                    
                    animateGesture();
                };

                this.performExplainGesture = (leftArm, rightArm, head) => {
                    if (!leftArm || !rightArm) return this.finishGesture();
                    
                    const originalLeft = { x: leftArm.rotation.x, z: leftArm.rotation.z };
                    const originalRight = { x: rightArm.rotation.x, z: rightArm.rotation.z };
                    const originalHead = head ? { y: head.rotation.y } : null;
                    const gestureDuration = 5000;
                    const startTime = Date.now();
                    
                    const animateGesture = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / gestureDuration, 1);
                        const time = elapsed * 0.001;
                        
                        // Gestos alternados das mãos como se explicando
                        const leftPhase = Math.sin(time * 2) * 0.4;
                        const rightPhase = Math.sin(time * 2 + Math.PI) * 0.3;
                        
                        leftArm.rotation.x = originalLeft.x - 0.6 + leftPhase;
                        leftArm.rotation.z = originalLeft.z - 0.3 + Math.abs(leftPhase) * 0.2;
                        
                        rightArm.rotation.x = originalRight.x - 0.5 + rightPhase;
                        rightArm.rotation.z = originalRight.z + 0.3 + Math.abs(rightPhase) * 0.2;
                        
                        // Cabeça acompanha a explicação
                        if (head && originalHead) {
                            head.rotation.y = originalHead.y + Math.sin(time * 0.8) * 0.2;
                        }
                        
                        if (progress >= 1) {
                            leftArm.rotation.x = originalLeft.x;
                            leftArm.rotation.z = originalLeft.z;
                            rightArm.rotation.x = originalRight.x;
                            rightArm.rotation.z = originalRight.z;
                            if (head && originalHead) {
                                head.rotation.y = originalHead.y;
                            }
                            this.finishGesture();
                        } else {
                            requestAnimationFrame(animateGesture);
                        }
                    };
                    
                    animateGesture();
                };

                this.performThinkGesture = (arm, head) => {
                    if (!arm) return this.finishGesture();
                    
                    const originalArm = { x: arm.rotation.x, z: arm.rotation.z };
                    const originalHead = head ? { x: head.rotation.x, y: head.rotation.y } : null;
                    const gestureDuration = 3500;
                    const startTime = Date.now();
                    
                    const animateGesture = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / gestureDuration, 1);
                        
                        if (progress < 0.3) {
                            // Levar mão ao queixo
                            const moveProgress = progress / 0.3;
                            arm.rotation.x = originalArm.x - moveProgress * 1.5;
                            arm.rotation.z = originalArm.z + moveProgress * 0.4;
                            
                            if (head && originalHead) {
                                head.rotation.x = originalHead.x + moveProgress * 0.2; // Olhar ligeiramente para baixo
                            }
                        } else if (progress < 0.7) {
                            // Manter posição pensativa
                            arm.rotation.x = originalArm.x - 1.5;
                            arm.rotation.z = originalArm.z + 0.4;
                            
                            if (head && originalHead) {
                                head.rotation.x = originalHead.x + 0.2;
                                // Pequenos movimentos de reflexão
                                head.rotation.y = originalHead.y + Math.sin((progress - 0.3) * 30) * 0.05;
                            }
                        } else {
                            // Voltar à posição normal
                            const returnProgress = (progress - 0.7) / 0.3;
                            const easedReturn = 1 - Math.pow(1 - returnProgress, 3);
                            
                            arm.rotation.x = (originalArm.x - 1.5) + easedReturn * 1.5;
                            arm.rotation.z = (originalArm.z + 0.4) - easedReturn * 0.4;
                            
                            if (head && originalHead) {
                                head.rotation.x = (originalHead.x + 0.2) - easedReturn * 0.2;
                                head.rotation.y = originalHead.y;
                            }
                        }
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateGesture);
                        } else {
                            arm.rotation.x = originalArm.x;
                            arm.rotation.z = originalArm.z;
                            if (head && originalHead) {
                                head.rotation.x = originalHead.x;
                                head.rotation.y = originalHead.y;
                            }
                            this.finishGesture();
                        }
                    };
                    
                    animateGesture();
                };

                this.performEncourageGesture = (leftArm, rightArm) => {
                    if (!leftArm || !rightArm) return this.finishGesture();
                    
                    const originalLeft = { x: leftArm.rotation.x, z: leftArm.rotation.z };
                    const originalRight = { x: rightArm.rotation.x, z: rightArm.rotation.z };
                    const gestureDuration = 2500;
                    const startTime = Date.now();
                    
                    const animateGesture = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / gestureDuration, 1);
                        
                        if (progress < 0.4) {
                            // Levantar punhos (gesto de comemoração)
                            const raiseProgress = progress / 0.4;
                            leftArm.rotation.x = originalLeft.x - raiseProgress * 1.4;
                            leftArm.rotation.z = originalLeft.z - raiseProgress * 0.3;
                            rightArm.rotation.x = originalRight.x - raiseProgress * 1.4;
                            rightArm.rotation.z = originalRight.z + raiseProgress * 0.3;
                        } else if (progress < 0.7) {
                            // Pequenos pumps de encorajamento
                            const pumpPhase = (progress - 0.4) / 0.3;
                            const pumpMotion = Math.sin(pumpPhase * Math.PI * 6) * 0.1;
                            
                            leftArm.rotation.x = originalLeft.x - 1.4 + pumpMotion;
                            leftArm.rotation.z = originalLeft.z - 0.3;
                            rightArm.rotation.x = originalRight.x - 1.4 + pumpMotion;
                            rightArm.rotation.z = originalRight.z + 0.3;
                        } else {
                            // Baixar braços
                            const lowerProgress = (progress - 0.7) / 0.3;
                            const easedLower = 1 - Math.pow(1 - lowerProgress, 3);
                            
                            leftArm.rotation.x = (originalLeft.x - 1.4) + easedLower * 1.4;
                            leftArm.rotation.z = (originalLeft.z - 0.3) + easedLower * 0.3;
                            rightArm.rotation.x = (originalRight.x - 1.4) + easedLower * 1.4;
                            rightArm.rotation.z = (originalRight.z + 0.3) - easedLower * 0.3;
                        }
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateGesture);
                        } else {
                            leftArm.rotation.x = originalLeft.x;
                            leftArm.rotation.z = originalLeft.z;
                            rightArm.rotation.x = originalRight.x;
                            rightArm.rotation.z = originalRight.z;
                            this.finishGesture();
                        }
                    };
                    
                    animateGesture();
                };

                this.finishGesture = () => {
                    AppState.drTuringAnimations.isGesturing = false;
                };

                // Iniciar animação idle
                startIdleAnimation();
                
                console.log('Sistema de animações humanizadas configurado para Dra. Turing');
            },

            setupDrTuringSpeech3D(model) {
                // Sistema de fala 3D com balões de texto na cena
                AppState.drTuringSpeech3D = {
                    currentBalloon: null,
                    isPlaying: false
                };

                // Criar balão de fala 3D
                const createSpeechBalloon = (text) => {
                    // Remover balão anterior se existir
                    if (AppState.drTuringSpeech3D.currentBalloon) {
                        AppState.scene.remove(AppState.drTuringSpeech3D.currentBalloon);
                    }

                    // Criar canvas para o texto
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 512;
                    canvas.height = 256;

                    // Configurar estilo do texto
                    context.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    context.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Borda
                    context.strokeStyle = '#00ff88';
                    context.lineWidth = 4;
                    context.strokeRect(0, 0, canvas.width, canvas.height);

                    // Texto
                    context.fillStyle = '#000';
                    context.font = 'bold 18px Arial';
                    context.textAlign = 'left';
                    
                    // Quebrar texto em linhas
                    const words = text.split(' ');
                    const lines = [];
                    let currentLine = '';
                    const maxWidth = canvas.width - 40;
                    
                    words.forEach(word => {
                        const testLine = currentLine + word + ' ';
                        const metrics = context.measureText(testLine);
                        if (metrics.width > maxWidth && currentLine !== '') {
                            lines.push(currentLine);
                            currentLine = word + ' ';
                        } else {
                            currentLine = testLine;
                        }
                    });
                    lines.push(currentLine);

                    // Desenhar linhas
                    const lineHeight = 22;
                    const startY = 30;
                    lines.forEach((line, index) => {
                        context.fillText(line, 20, startY + (index * lineHeight));
                    });

                    // Adicionar ícone da Dra. Turing
                    context.font = '24px Arial';
                    context.fillText('👩‍🔬', canvas.width - 50, 30);

                    // Criar material do sprite
                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMaterial = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true
                    });
                    
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.position.set(
                        model.position.x + 3,
                        model.position.y + 4,
                        model.position.z
                    );
                    sprite.scale.set(6, 3, 1);
                    
                    AppState.scene.add(sprite);
                    AppState.drTuringSpeech3D.currentBalloon = sprite;

                    return sprite;
                };

                // Método público para fazer a Dra. Turing falar
                AppState.drTuringSpeech3D.speak = (text, duration = 5000) => {
                    if (AppState.drTuringSpeech3D.isPlaying) return;
                    
                    AppState.drTuringSpeech3D.isPlaying = true;
                    
                    // Iniciar animação de fala
                    AppState.drTuringAnimations.startSpeaking();
                    
                    // Intensificar iluminação quando fala
                    if (AppState.drTuringLighting) {
                        AppState.drTuringLighting.intensifyWhenSpeaking();
                    }
                    
                    // Criar balão de fala
                    const balloon = createSpeechBalloon(text);
                    
                    // Animação de entrada do balão
                    balloon.scale.set(0, 0, 0);
                    const startTime = Date.now();
                    const animateBalloon = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / 500, 1);
                        
                        balloon.scale.set(
                            6 * progress,
                            3 * progress,
                            1
                        );
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateBalloon);
                        }
                    };
                    animateBalloon();
                    
                    // Fazer balão seguir a Dra. Turing
                    const followDrTuring = () => {
                        if (balloon && balloon.parent) {
                            balloon.position.set(
                                model.position.x + 3,
                                model.position.y + 4,
                                model.position.z
                            );
                            
                            if (AppState.drTuringSpeech3D.isPlaying) {
                                requestAnimationFrame(followDrTuring);
                            }
                        }
                    };
                    followDrTuring();
                    
                    // Remover balão após duração
                    setTimeout(() => {
                        AppState.drTuringSpeech3D.isPlaying = false;
                        AppState.drTuringAnimations.stopSpeaking();
                        
                        // Voltar iluminação ao normal
                        if (AppState.drTuringLighting) {
                            AppState.drTuringLighting.normalIntensity();
                        }
                        
                        if (balloon && balloon.parent) {
                            // Animação de saída
                            const fadeOut = () => {
                                balloon.material.opacity -= 0.05;
                                if (balloon.material.opacity > 0) {
                                    requestAnimationFrame(fadeOut);
                                } else {
                                    AppState.scene.remove(balloon);
                                    AppState.drTuringSpeech3D.currentBalloon = null;
                                }
                            };
                            fadeOut();
                        }
                    }, duration);
                };
            },

            drTuringSpeak3D(text, duration = 5000) {
                if (AppState.drTuringSpeech3D && AppState.drTuringSpeech3D.speak) {
                    AppState.drTuringSpeech3D.speak(text, duration);
                }
            },

            addDrTuringLighting(model) {
                // Luz principal da Dra. Turing
                const drTuringLight = new THREE.SpotLight(0xffffff, 2, 20, Math.PI / 6, 0.5, 1);
                drTuringLight.position.set(model.position.x, model.position.y + 8, model.position.z + 5);
                drTuringLight.target.position.copy(model.position);
                drTuringLight.castShadow = true;
                drTuringLight.shadow.mapSize.width = 1024;
                drTuringLight.shadow.mapSize.height = 1024;
                drTuringLight.name = 'dr-turing-spotlight';
                
                AppState.scene.add(drTuringLight);
                AppState.scene.add(drTuringLight.target);
                
                // Luz de preenchimento suave
                const fillLight = new THREE.PointLight(0x88ccff, 0.8, 15);
                fillLight.position.set(model.position.x - 3, model.position.y + 2, model.position.z + 3);
                fillLight.name = 'dr-turing-fill-light';
                AppState.scene.add(fillLight);
                
                // Luz de contorno para efeito dramático
                const rimLight = new THREE.DirectionalLight(0x00ff88, 0.5);
                rimLight.position.set(model.position.x + 5, model.position.y + 3, model.position.z - 5);
                rimLight.target.position.copy(model.position);
                rimLight.name = 'dr-turing-rim-light';
                AppState.scene.add(rimLight);
                AppState.scene.add(rimLight.target);
                
                // Sistema de intensidade dinâmica quando fala
                AppState.drTuringLighting = {
                    spotlight: drTuringLight,
                    fillLight: fillLight,
                    rimLight: rimLight,
                    
                    intensifyWhenSpeaking: () => {
                        drTuringLight.intensity = 3;
                        fillLight.intensity = 1.2;
                        rimLight.intensity = 0.8;
                    },
                    
                    normalIntensity: () => {
                        drTuringLight.intensity = 2;
                        fillLight.intensity = 0.8;
                        rimLight.intensity = 0.5;
                    }
                };
            },

            createDrTuringPlaceholder() {
                // Criar um placeholder humanóide mais realista se o modelo 3D falhar ao carregar
                const group = new THREE.Group();
                
                // Criar estrutura hierárquica para animações mais naturais
                const torso = new THREE.Group();
                const head = new THREE.Group();
                const leftArm = new THREE.Group();
                const rightArm = new THREE.Group();
                const leftLeg = new THREE.Group();
                const rightLeg = new THREE.Group();
                
                // Corpo principal (tronco)
                const bodyGeometry = new THREE.CapsuleGeometry(0.6, 2, 8, 16);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: 0xf8f8ff, // Jaleco branco
                    transparent: false,
                    opacity: 1.0,
                    shininess: 30
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1;
                body.castShadow = true;
                torso.add(body);
                
                // Cabeça com formato mais realista
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const headMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffdbac, // Cor de pele realista
                    transparent: false,
                    opacity: 1.0,
                    shininess: 20
                });
                const headMesh = new THREE.Mesh(headGeometry, headMaterial);
                headMesh.position.y = 1.5; // Relativo ao torso
                headMesh.castShadow = true;
                head.add(headMesh);
                
                // Cabelo mais detalhado
                const hairGeometry = new THREE.SphereGeometry(0.42, 16, 16);
                const hairMaterial = new THREE.MeshPhongMaterial({
                    color: 0x2d1b0e, // Castanho escuro
                    transparent: false,
                    opacity: 1.0,
                    shininess: 80
                });
                const hair = new THREE.Mesh(hairGeometry, hairMaterial);
                hair.position.y = 1.6;
                hair.scale.set(1, 0.8, 1);
                hair.castShadow = true;
                head.add(hair);
                
                // Olhos expressivos
                const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const eyeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x4a90e2,
                    emissive: 0x001122,
                    emissiveIntensity: 0.2,
                    shininess: 100
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.15, 1.55, 0.35);
                leftEye.name = 'leftEye';
                head.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.15, 1.55, 0.35);
                rightEye.name = 'rightEye';
                head.add(rightEye);
                
                // Nariz sutil
                const noseGeometry = new THREE.ConeGeometry(0.03, 0.1, 6);
                const noseMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffdbac,
                    shininess: 10
                });
                const nose = new THREE.Mesh(noseGeometry, noseMaterial);
                nose.position.set(0, 1.5, 0.38);
                nose.rotation.x = Math.PI / 2;
                head.add(nose);
                
                // Braços com articulações
                const armGeometry = new THREE.CapsuleGeometry(0.15, 1.2, 8, 16);
                const armMaterial = new THREE.MeshPhongMaterial({
                    color: 0xf8f8ff, // Jaleco
                    shininess: 30
                });
                
                // Braço esquerdo
                const leftArmMesh = new THREE.Mesh(armGeometry, armMaterial);
                leftArmMesh.position.set(0, -0.3, 0);
                leftArmMesh.castShadow = true;
                leftArm.add(leftArmMesh);
                leftArm.position.set(-0.8, 1.5, 0);
                
                // Braço direito
                const rightArmMesh = new THREE.Mesh(armGeometry, armMaterial);
                rightArmMesh.position.set(0, -0.3, 0);
                rightArmMesh.castShadow = true;
                rightArm.add(rightArmMesh);
                rightArm.position.set(0.8, 1.5, 0);
                
                // Mãos
                const handGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                const handMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffdbac,
                    shininess: 20
                });
                
                const leftHand = new THREE.Mesh(handGeometry, handMaterial);
                leftHand.position.set(0, -0.8, 0);
                leftHand.castShadow = true;
                leftArm.add(leftHand);
                
                const rightHand = new THREE.Mesh(handGeometry, handMaterial);
                rightHand.position.set(0, -0.8, 0);
                rightHand.castShadow = true;
                rightArm.add(rightHand);
                
                // Pernas (mais simples)
                const legGeometry = new THREE.CapsuleGeometry(0.2, 1.5, 8, 16);
                const legMaterial = new THREE.MeshPhongMaterial({
                    color: 0x2c3e50, // Calça escura
                    shininess: 10
                });
                
                const leftLegMesh = new THREE.Mesh(legGeometry, legMaterial);
                leftLegMesh.position.set(0, -0.75, 0);
                leftLegMesh.castShadow = true;
                leftLeg.add(leftLegMesh);
                leftLeg.position.set(-0.3, 0.25, 0);
                
                const rightLegMesh = new THREE.Mesh(legGeometry, legMaterial);
                rightLegMesh.position.set(0, -0.75, 0);
                rightLegMesh.castShadow = true;
                rightLeg.add(rightLegMesh);
                rightLeg.position.set(0.3, 0.25, 0);
                
                // Sapatos
                const shoeGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.4);
                const shoeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x000000,
                    shininess: 50
                });
                
                const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
                leftShoe.position.set(0, -1.45, 0.1);
                leftShoe.castShadow = true;
                leftLeg.add(leftShoe);
                
                const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
                rightShoe.position.set(0, -1.45, 0.1);
                rightShoe.castShadow = true;
                rightLeg.add(rightShoe);
                
                // Montar hierarquia
                torso.position.y = 0;
                head.position.y = 2;
                
                group.add(torso);
                group.add(head);
                group.add(leftArm);
                group.add(rightArm);
                group.add(leftLeg);
                group.add(rightLeg);
                
                // Adicionar nomes para animação
                torso.name = 'spine';
                head.name = 'head';
                leftArm.name = 'left_arm';
                rightArm.name = 'right_arm';
                leftLeg.name = 'left_leg';
                rightLeg.name = 'right_leg';
                
                // Criar grupo de olhos para piscar
                const eyesGroup = new THREE.Group();
                eyesGroup.add(leftEye);
                eyesGroup.add(rightEye);
                eyesGroup.name = 'eyes';
                head.add(eyesGroup);
                
                // Posicionar na cena
                group.position.set(-8, 0, 5);
                group.scale.set(2.5, 2.5, 2.5);
                group.rotation.y = Math.PI / 4;
                
                AppState.scene.add(group);
                AppState.drTuring = group;
                
                // Configurar animações com o novo sistema hierárquico
                this.setupDrTuringAnimations(group);
                this.setupDrTuringSpeech3D(group);
                
                // Adicionar iluminação especial
                this.addDrTuringLighting(group);
                
                // Adicionar luz de destaque adicional para placeholder
                const turingLight = new THREE.PointLight(0xffffff, 1.5, 15);
                turingLight.position.set(-8, 4, 5);
                AppState.scene.add(turingLight);
                
                // Criar rótulo mais elegante
                this.createDrTuringLabel();
                
                // Animar entrada suave
                this.animatePlaceholderEntrance(group);
                
                // Mostrar mensagem inicial
                setTimeout(() => {
                    this.drTuringSpeak3D('Olá! Bem-vindo ao Nexo Dash! Sou a Dra. Ana Turing, sua mentora nesta jornada fascinante. Juntos, construiremos um dashboard completo para análise de doenças cardíacas usando Python e Dash. Está pronto para esta missão?');
                }, 2000);
                
                console.log('Placeholder humanizado da Dra. Turing criado com sucesso');
            },

            createDrTuringLabel() {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 128;
                
                // Fundo elegante com gradiente
                const gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, 'rgba(248, 248, 255, 0.95)');
                gradient.addColorStop(0.5, 'rgba(138, 200, 255, 0.95)');
                gradient.addColorStop(1, 'rgba(0, 200, 255, 0.95)');
                context.fillStyle = gradient;
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Borda holográfica
                context.strokeStyle = '#00ff88';
                context.lineWidth = 6;
                context.strokeRect(0, 0, canvas.width, canvas.height);
                
                // Adicionais visuais
                context.strokeStyle = '#ffffff';
                context.lineWidth = 2;
                context.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
                
                // Texto com sombra
                context.shadowColor = '#000';
                context.shadowBlur = 4;
                context.shadowOffsetX = 2;
                context.shadowOffsetY = 2;
                
                // Nome principal
                context.fillStyle = '#000';
                context.font = 'bold 36px Arial';
                context.textAlign = 'center';
                context.fillText('Dra. Ana Turing', canvas.width / 2, 50);
                
                // Título profissional
                context.font = 'bold 24px Arial';
                context.fillText('Mentora Virtual IA', canvas.width / 2, 85);
                
                // Ícone de IA
                context.font = '30px Arial';
                context.fillText('🤖', 50, 45);
                context.fillText('💡', canvas.width - 50, 45);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(-8, 7, 5);
                sprite.scale.set(6, 1.5, 1);
                sprite.name = 'dr-turing-label';
                
                AppState.scene.add(sprite);
            },

            animatePlaceholderEntrance(group) {
                // Animação de entrada dramática
                group.position.y = -10; // Começar enterrado
                group.scale.set(0.1, 0.1, 0.1); // Muito pequeno
                group.rotation.y = Math.PI * 2; // Rotação completa
                
                const targetY = 0;
                const targetScale = 2.5;
                const targetRotation = Math.PI / 4;
                
                const startTime = Date.now();
                const duration = 2000;
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Easing dramático
                    const easedProgress = 1 - Math.pow(1 - progress, 4);
                    
                    // Posição Y com bounce
                    const bounceProgress = this.easeOutBounce(progress);
                    group.position.y = -10 + (targetY + 10) * bounceProgress;
                    
                    // Escala com elastic
                    const elasticProgress = this.easeOutElastic(progress);
                    const scale = 0.1 + (targetScale - 0.1) * elasticProgress;
                    group.scale.set(scale, scale, scale);
                    
                    // Rotação suave
                    group.rotation.y = Math.PI * 2 * (1 - easedProgress) + targetRotation * easedProgress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // Adicionar pequena animação idle final
                        this.addFinalIdleAnimation(group);
                    }
                };
                
                animate();
            },

            addFinalIdleAnimation(group) {
                // Pequena animação de "I'm alive!" após entrada
                let bounceCount = 0;
                const maxBounces = 3;
                const bounceHeight = 0.3;
                
                const finalBounce = () => {
                    if (bounceCount >= maxBounces) return;
                    
                    const startY = group.position.y;
                    const startTime = Date.now();
                    const bounceDuration = 400;
                    
                    const animateBounce = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = elapsed / bounceDuration;
                        
                        if (progress < 0.5) {
                            // Subir
                            group.position.y = startY + (progress * 2) * bounceHeight;
                        } else {
                            // Descer
                            group.position.y = startY + ((1 - progress) * 2) * bounceHeight;
                        }
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateBounce);
                        } else {
                            group.position.y = startY;
                            bounceCount++;
                            if (bounceCount < maxBounces) {
                                setTimeout(finalBounce, 200);
                            }
                        }
                    };
                    
                    animateBounce();
                };
                
                setTimeout(finalBounce, 500);
            },

            easeOutBounce(t) {
                if (t < 1/2.75) {
                    return 7.5625 * t * t;
                } else if (t < 2/2.75) {
                    return 7.5625 * (t -= 1.5/2.75) * t + 0.75;
                } else if (t < 2.5/2.75) {
                    return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;
                } else {
                    return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;
                }
            },

            easeOutElastic(t) {
                if (t === 0) return 0;
                if (t === 1) return 1;
                const p = 0.3;
                const s = p / 4;
                return Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
            },

            createLaboratoryPlatform() {
                // Criar plataforma circular holográfica
                const platformGeometry = new THREE.CylinderGeometry(8, 8, 0.2, 32);
                const platformMaterial = new THREE.MeshLambertMaterial({
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.3,
                    emissive: 0x004422
                });
                const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                platform.position.y = -0.1;
                platform.receiveShadow = true;
                AppState.scene.add(platform);

                // Criar grid holográfico
                const gridHelper = new THREE.GridHelper(16, 16, 0x00ff88, 0x00ff88);
                gridHelper.material.opacity = 0.2;
                gridHelper.material.transparent = true;
                AppState.scene.add(gridHelper);

                // Criar núcleo central (será usado nos módulos)
                const coreGeometry = new THREE.SphereGeometry(0.5, 32, 32);
                const coreMaterial = new THREE.MeshLambertMaterial({
                    color: 0x00ccff,
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0x002244
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.y = 2;
                core.name = 'laboratory-core';
                AppState.scene.add(core);
            },

            animate() {
                AppState.animationId = requestAnimationFrame(this.animate.bind(this));
                
                // Animar núcleo central
                const core = AppState.scene.getObjectByName('laboratory-core');
                if (core) {
                    core.rotation.y += 0.01;
                    core.position.y = 2 + Math.sin(Date.now() * 0.001) * 0.2;
                }

                AppState.controls.update();
                AppState.renderer.render(AppState.scene, AppState.camera);
            },

            onWindowResize() {
                AppState.camera.aspect = window.innerWidth / window.innerHeight;
                AppState.camera.updateProjectionMatrix();
                AppState.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        };

        // Sistema Pyodide para execução de Python
        const PyodideSystem = {
            async init() {
                try {
                    LoadingSystem.updateProgress(3, 'Inicializando Pyodide...');
                    
                    AppState.pyodide = await loadPyodide({
                        indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
                    });

                    LoadingSystem.updateProgress(4, 'Carregando pacotes Python...');

                    // Carregar pacotes essenciais
                    await AppState.pyodide.loadPackage([
                        'micropip',
                        'pandas',
                        'numpy'
                    ]);

                    // Instalar dash via micropip
                    const micropip = AppState.pyodide.pyimport('micropip');
                    await micropip.install([
                        'dash',
                        'plotly',
                        'dash-html-components',
                        'dash-core-components'
                    ]);

                    console.log('Pyodide inicializado com sucesso!');
                    return true;
                } catch (error) {
                    console.error('Erro ao inicializar Pyodide:', error);
                    LoadingSystem.updateProgress(4, 'Erro ao carregar Python (continuando...)');
                    return false;
                }
            },

            runCode(pythonCode) {
                if (!AppState.pyodide) {
                    console.error('Pyodide não foi inicializado');
                    return null;
                }

                try {
                    return AppState.pyodide.runPython(pythonCode);
                } catch (error) {
                    console.error('Erro ao executar código Python:', error);
                    return null;
                }
            }
        };

        // Sistema de Interface
        const UISystem = {
            showPanel(title, content, actions = []) {
                const panel = document.getElementById('main-panel');
                const titleEl = document.getElementById('panel-title');
                const contentEl = document.getElementById('panel-content');
                const actionsEl = document.getElementById('panel-actions');

                titleEl.textContent = title;
                contentEl.innerHTML = content;
                
                // Limpar ações anteriores
                actionsEl.innerHTML = '';
                
                // Adicionar novas ações
                actions.forEach(action => {
                    const button = document.createElement('button');
                    button.className = 'holographic-button';
                    button.textContent = action.label;
                    button.onclick = action.callback;
                    actionsEl.appendChild(button);
                });

                // Mostrar painel (CSS handle positioning)
                panel.style.display = 'block';
                
                // Scroll to top of panel content
                contentEl.scrollTop = 0;
            },

            hidePanel() {
                const panel = document.getElementById('main-panel');
                panel.style.display = 'none';
            }
        };

        // Sistema de Módulos
        const ModuleSystem = {
            currentStep: 0,
            modules: [
                {
                    title: 'Módulo 0: Calibração da Estação',
                    steps: [
                        {
                            title: 'Bem-vindo ao Nexo Dash',
                            content: `
                                <div style="text-align: center; margin-bottom: 2rem;">
                                    <div style="font-size: 3rem; margin-bottom: 1rem;">🧬</div>
                                    <p><strong>Bem-vindo ao Laboratório Virtual Nexo Dash!</strong></p>
                                </div>
                                <p>Eu sou a <strong>Dra. Ana Turing</strong>, sua mentora nesta jornada de aprendizado.</p>
                                <p>Você foi recrutado para uma missão importante: analisar fatores de risco de doenças cardíacas usando um dataset real do Kaggle.</p>
                                <p><strong>Sua missão:</strong> Construir um dashboard profissional usando Python, Dash e as melhores práticas da indústria.</p>
                                <p>Vamos começar calibrando sua estação de trabalho!</p>
                            `,
                            actions: [{ label: 'Aceitar Missão', callback: () => {
                                // Fazer a Dra. Turing falar quando o usuário aceita a missão
                                ThreeJSSystem.drTuringSpeak3D('Excelente! Você aceitou a missão. Agora vamos configurar seu ambiente de desenvolvimento profissional. Primeiro, precisamos instalar o VS Code, o editor de código mais usado na indústria.', 6000);
                                ModuleSystem.nextStep();
                            }}]
                        },
                        {
                            title: 'Passo 1: Instalação do VS Code',
                            content: `
                                <div style="background: rgba(0,100,100,0.2); padding: 1rem; border-radius: 5px; margin-bottom: 1rem;">
                                    <h4>🔧 Configuração do Ambiente</h4>
                                </div>
                                <p><strong>Visual Studio Code</strong> é nosso editor principal. Se ainda não tem instalado:</p>
                                <ol>
                                    <li>Acesse: <a href="https://code.visualstudio.com/" target="_blank" style="color: #00ccff;">https://code.visualstudio.com/</a></li>
                                    <li>Baixe a versão para seu sistema operacional</li>
                                    <li>Execute a instalação com as configurações padrão</li>
                                    <li>Abra o VS Code após a instalação</li>
                                </ol>
                                <p><strong>Extensões recomendadas:</strong></p>
                                <ul>
                                    <li><strong>Python (Microsoft)</strong>: Suporte completo para Python</li>
                                    <li><strong>Ruff (Astral Software)</strong>: Linter e formatter super rápido</li>
                                    <li><strong>Error Lens</strong>: Mostra erros diretamente no código</li>
                                    <li><strong>Data Wrangler (Microsoft)</strong>: Visualização de dados CSV/Excel</li>
                                </ul>
                                <p><em>💡 Essas extensões transformarão seu VS Code numa IDE Python profissional!</em></p>
                            `,
                            actions: [
                                { label: 'VS Code Instalado', callback: () => {
                                    ThreeJSSystem.drTuringSpeak3D('Perfeito! Com o VS Code instalado, agora vamos configurar o uv, o gerenciador de pacotes Python mais rápido e moderno da atualidade.', 5000);
                                    ModuleSystem.nextStep();
                                }},
                                { label: 'Já Tenho VS Code', callback: () => {
                                    ThreeJSSystem.drTuringSpeak3D('Ótimo! Você já tem o VS Code. Agora vamos para o próximo passo: instalar o uv para gerenciar nossos pacotes Python.', 5000);
                                    ModuleSystem.nextStep();
                                }}
                            ]
                        },
                        {
                            title: 'Passo 2: Instalação do uv',
                            content: `
                                <div style="background: rgba(100,0,100,0.2); padding: 1rem; border-radius: 5px; margin-bottom: 1rem;">
                                    <h4>⚡ Gerenciador de Pacotes Moderno</h4>
                                </div>
                                <p><strong>uv</strong> é o gerenciador de pacotes Python mais rápido da atualidade (Astral).</p>
                                
                                <p><strong>Windows (PowerShell):</strong></p>
                                <div style="background: #1a1a1a; padding: 1rem; border-radius: 5px; font-family: monospace; margin: 1rem 0;">
                                    powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"
                                </div>
                                
                                <p><strong>macOS/Linux:</strong></p>
                                <div style="background: #1a1a1a; padding: 1rem; border-radius: 5px; font-family: monospace; margin: 1rem 0;">
                                    curl -LsSf https://astral.sh/uv/install.sh | sh
                                </div>
                                
                                <p><strong>Verificar instalação:</strong></p>
                                <div style="background: #1a1a1a; padding: 1rem; border-radius: 5px; font-family: monospace; margin: 1rem 0;">
                                    uv --version
                                </div>
                                
                                <p><em>⚠️ Pode ser necessário reiniciar o terminal após a instalação.</em></p>
                            `,
                            actions: [
                                { label: 'uv Instalado', callback: () => {
                                    ThreeJSSystem.drTuringSpeak3D('Excelente! O uv está instalado e pronto. Agora vamos criar a estrutura do nosso projeto de análise cardíaca usando as melhores práticas da indústria.', 5000);
                                    ModuleSystem.nextStep();
                                }}
                            ]
                        },
                        {
                            title: 'Passo 3: Criação do Projeto',
                            content: `
                                <div style="background: rgba(0,100,0,0.2); padding: 1rem; border-radius: 5px; margin-bottom: 1rem;">
                                    <h4>🏗️ Estrutura do Projeto</h4>
                                </div>
                                <p>Agora vamos criar a estrutura do nosso projeto de análise cardíaca:</p>
                                
                                <p><strong>1. Criar pasta do projeto:</strong></p>
                                <div style="background: #1a1a1a; padding: 1rem; border-radius: 5px; font-family: monospace; margin: 1rem 0;">
                                    mkdir dashboard-cardiaco<br>
                                    cd dashboard-cardiaco
                                </div>
                                
                                <p><strong>2. Inicializar projeto com uv:</strong></p>
                                <div style="background: #1a1a1a; padding: 1rem; border-radius: 5px; font-family: monospace; margin: 1rem 0;">
                                    uv init
                                </div>
                                
                                <p><strong>3. Abrir no VS Code:</strong></p>
                                <div style="background: #1a1a1a; padding: 1rem; border-radius: 5px; font-family: monospace; margin: 1rem 0;">
                                    code .
                                </div>
                                
                                <p>✨ O comando <code>uv init</code> criará automaticamente o arquivo <code>pyproject.toml</code> que é o centro de controle do projeto!</p>
                            `,
                            actions: [
                                { label: 'Projeto Criado', callback: () => {
                                    ThreeJSSystem.drTuringSpeak3D('Fantástico! A estrutura do projeto está criada. Agora vamos instalar as bibliotecas essenciais para construir nosso dashboard de análise cardíaca.', 5000);
                                    ModuleSystem.nextStep();
                                }}
                            ]
                        },
                        {
                            title: 'Passo 4: Instalação de Dependências',
                            content: `
                                <div style="background: rgba(100,100,0,0.2); padding: 1rem; border-radius: 5px; margin-bottom: 1rem;">
                                    <h4>📦 Bibliotecas Essenciais</h4>
                                </div>
                                <p>Vamos instalar as bibliotecas que usaremos no dashboard:</p>
                                
                                <div style="background: #1a1a1a; padding: 1rem; border-radius: 5px; font-family: monospace; margin: 1rem 0;">
                                    uv add dash dash-mantine-components dash-chart-editor pandas plotly
                                </div>
                                
                                <p><strong>O que cada biblioteca faz:</strong></p>
                                <ul>
                                    <li><strong>dash</strong>: Framework principal para dashboards web</li>
                                    <li><strong>dash-mantine-components</strong>: Componentes UI modernos</li>
                                    <li><strong>dash-chart-editor</strong>: Editor visual de gráficos</li>
                                    <li><strong>pandas</strong>: Manipulação e análise de dados</li>
                                    <li><strong>plotly</strong>: Criação de gráficos interativos</li>
                                </ul>
                                
                                <p>🚀 O uv resolverá automaticamente todas as dependências e criará um ambiente virtual!</p>
                            `,
                            actions: [
                                { label: 'Dependências Instaladas', callback: () => {
                                    ThreeJSSystem.drTuringSpeak3D('Perfeito! Todas as bibliotecas estão instaladas. Sua estação de trabalho está completamente calibrada e pronta para a missão! Agora vamos carregar o blueprint do projeto.', 6000);
                                    ModuleSystem.nextStep();
                                }}
                            ]
                        },
                        {
                            title: 'Calibração Completa!',
                            content: `
                                <div style="text-align: center; margin-bottom: 2rem;">
                                    <div style="font-size: 3rem; margin-bottom: 1rem;">✅</div>
                                    <p><strong>Estação de Trabalho Calibrada!</strong></p>
                                </div>
                                <p>Excelente trabalho! Sua estação está configurada com:</p>
                                <ul>
                                    <li>✅ VS Code configurado</li>
                                    <li>✅ uv instalado e funcionando</li>
                                    <li>✅ Projeto inicializado</li>
                                    <li>✅ Dependências instaladas</li>
                                </ul>
                                
                                <p><strong>Próximo passo:</strong> Vamos carregar o blueprint do projeto e os dados que analisaremos!</p>
                                
                                <div style="background: rgba(0,255,136,0.1); padding: 1rem; border-radius: 5px; margin-top: 1rem;">
                                    <p><em>💡 Dica: Mantenha o VS Code aberto com seu projeto. Usaremos ele nos próximos módulos!</em></p>
                                </div>
                            `,
                            actions: [
                                { label: 'Ir para Módulo 1', callback: () => {
                                    ThreeJSSystem.drTuringSpeak3D('Excelente trabalho! Sua estação está calibrada. Agora vamos carregar o blueprint 3D do projeto e os dados que analisaremos. Prepare-se para ver a arquitetura ganhar vida!', 7000);
                                    ModuleSystem.nextModule();
                                }}
                            ]
                        }
                    ]
                },
                {
                    title: 'Módulo 1: Blueprint do Projeto',
                    steps: [
                        {
                            title: 'Carregando Blueprint do Projeto',
                            content: `
                                <div style="text-align: center; margin-bottom: 2rem;">
                                    <div style="font-size: 3rem; margin-bottom: 1rem;">🗂️</div>
                                    <p><strong>Arquitetura do Projeto</strong></p>
                                </div>
                                <p>Agora vou mostrar a estrutura profissional que seu projeto deve ter.</p>
                                <p>Observe a visualização 3D que aparecerá ao lado - cada pasta e arquivo tem sua função específica.</p>
                                <p><strong>Clique nos elementos 3D</strong> para ver suas descrições!</p>
                            `,
                            actions: [
                                { label: 'Carregar Blueprint', callback: () => {
                                    ThreeJSSystem.drTuringSpeak3D('Iniciando carregamento do blueprint 3D! Observe como a arquitetura do projeto se materializa no laboratório virtual. Cada componente tem uma função específica.', 6000);
                                    ModuleSystem.load3DBlueprint();
                                }}
                            ]
                        },
                        {
                            title: 'Estrutura de Pastas Profissional',
                            content: `
                                <div style="background: rgba(0,100,100,0.2); padding: 1rem; border-radius: 5px; margin-bottom: 1rem;">
                                    <h4>🏗️ Organização Modular</h4>
                                </div>
                                <p>Esta é a estrutura que implementaremos:</p>
                                <div style="background: #1a1a1a; padding: 1rem; border-radius: 5px; font-family: monospace; font-size: 0.9rem;">
dashboard-cardiaco/<br>
├── app/<br>
│   ├── __init__.py<br>
│   ├── models.py<br>
│   ├── routers.py<br>
│   ├── views.py<br>
│   └── static/<br>
├── data/<br>
├── utils/<br>
├── tests/<br>
├── main.py<br>
└── pyproject.toml
                                </div>
                                <p><strong>Benefícios desta estrutura:</strong></p>
                                <ul>
                                    <li>Código organizado e fácil de manter</li>
                                    <li>Separação clara de responsabilidades</li>
                                    <li>Facilita trabalho em equipe</li>
                                    <li>Padrão da indústria</li>
                                </ul>
                            `,
                            actions: [
                                { label: 'Criar Estrutura', callback: () => {
                                    ThreeJSSystem.drTuringSpeak3D('Excelente! Agora você entende a organização modular. Esta estrutura facilita a manutenção e o trabalho em equipe. Vamos baixar os dados que analisaremos.', 6000);
                                    ModuleSystem.nextStep();
                                }}
                            ]
                        },
                        {
                            title: 'Download do Dataset',
                            content: `
                                <div style="background: rgba(100,0,0,0.2); padding: 1rem; border-radius: 5px; margin-bottom: 1rem;">
                                    <h4>❤️ Dados de Doenças Cardíacas</h4>
                                </div>
                                <p>Agora vamos baixar o dataset que analisaremos:</p>
                                
                                <p><strong>Dataset:</strong> Heart Disease Dataset (Kaggle)</p>
                                <p><strong>Conteúdo:</strong> Dados clínicos de pacientes com fatores de risco cardíaco</p>
                                
                                <p><strong>1. Criar pasta data:</strong></p>
                                <div style="background: #1a1a1a; padding: 1rem; border-radius: 5px; font-family: monospace; margin: 1rem 0;">
                                    mkdir data
                                </div>
                                
                                <p><strong>2. Download direto:</strong></p>
                                <a href="https://www.kaggle.com/api/v1/datasets/download/johnsmith88/heart-disease-dataset" 
                                   target="_blank" 
                                   style="color: #00ccff; text-decoration: none; background: rgba(0,200,255,0.2); padding: 0.5rem 1rem; border-radius: 5px; display: inline-block; margin: 1rem 0;">
                                    📥 Baixar Heart Disease Dataset
                                </a>
                                
                                <p><strong>3. Extrair para a pasta data/</strong></p>
                                <p><em>💡 O arquivo virá compactado (.zip). Extraia o CSV para dentro da pasta data/</em></p>
                            `,
                            actions: [
                                { label: 'Dataset Baixado', callback: () => {
                                    ThreeJSSystem.drTuringSpeak3D('Perfeito! O dataset de doenças cardíacas está carregado. Agora temos todos os ingredientes para construir um dashboard incrível. A missão está pronta para começar!', 6000);
                                    ModuleSystem.nextStep();
                                }}
                            ]
                        },
                        {
                            title: 'Blueprint Carregado!',
                            content: `
                                <div style="text-align: center; margin-bottom: 2rem;">
                                    <div style="font-size: 3rem; margin-bottom: 1rem;">🎯</div>
                                    <p><strong>Missão Preparada!</strong></p>
                                </div>
                                <p>Perfeito! Agora temos tudo pronto:</p>
                                <ul>
                                    <li>✅ Estrutura do projeto definida</li>
                                    <li>✅ Dataset de doenças cardíacas baixado</li>
                                    <li>✅ Arquitetura 3D visualizada</li>
                                    <li>✅ Ambiente de desenvolvimento pronto</li>
                                </ul>
                                
                                <p><strong>Próximos módulos:</strong> Construção iterativa do dashboard</p>
                                <ul>
                                    <li>Módulo 2: Núcleo do servidor Dash</li>
                                    <li>Módulo 3: Layout inicial</li>
                                    <li>Módulo 4: Primeira visualização</li>
                                    <li>Módulo 5: Interatividade com callbacks</li>
                                    <li>E muito mais...</li>
                                </ul>
                                
                                <div style="background: rgba(0,255,136,0.1); padding: 1rem; border-radius: 5px; margin-top: 1rem;">
                                    <p><em>🚀 Agora você tem uma base sólida para construir dashboards profissionais!</em></p>
                                </div>
                            `,
                            actions: [
                                { label: 'Explorar Ambiente', callback: () => {
                                    ThreeJSSystem.drTuringSpeak3D('Explore o ambiente 3D! Clique nos blocos da arquitetura para aprender sobre cada componente. Quando estiver pronto, voltaremos para continuar construindo o dashboard.', 7000);
                                    UISystem.hidePanel();
                                }},
                                { label: 'Ver Próximos Módulos', callback: () => {
                                    ThreeJSSystem.drTuringSpeak3D('Quer saber o que vem pela frente? Vou mostrar os próximos módulos da nossa jornada de construção do dashboard.', 5000);
                                    ModuleSystem.showUpcomingModules();
                                }}
                            ]
                        }
                    ]
                }
            ],

            nextModule() {
                AppState.currentModule++;
                this.currentStep = 0;
                if (AppState.currentModule < this.modules.length) {
                    this.showCurrentStep();
                } else {
                    this.showUpcomingModules();
                }
            },

            nextStep() {
                this.currentStep++;
                const currentModule = this.modules[AppState.currentModule];
                if (this.currentStep < currentModule.steps.length) {
                    this.showCurrentStep();
                } else {
                    this.nextModule();
                }
            },

            showCurrentStep() {
                const currentModule = this.modules[AppState.currentModule];
                const currentStep = currentModule.steps[this.currentStep];
                UISystem.showPanel(currentStep.title, currentStep.content, currentStep.actions);
            },

            startFirstModule() {
                AppState.currentModule = 0;
                this.currentStep = 0;
                this.showCurrentStep();
            },

            load3DBlueprint() {
                console.log('Carregando blueprint 3D...');
                // Criar visualização 3D da estrutura do projeto
                this.create3DProjectStructure();
                
                // Ajustar câmera para mostrar melhor o blueprint
                this.focusCameraOnBlueprint();
                
                console.log('Blueprint 3D carregado, avançando para próximo passo...');
                this.nextStep();
            },

            focusCameraOnBlueprint() {
                // Salvar posição original da câmera
                const originalPos = { 
                    x: AppState.camera.position.x, 
                    y: AppState.camera.position.y, 
                    z: AppState.camera.position.z 
                };
                
                // Posição otimizada para visualizar o blueprint
                const targetPos = { x: 6, y: 8, z: 10 };
                const targetLookAt = { x: 0, y: 2.5, z: 0 };
                
                const startTime = Date.now();
                const duration = 3000;
                
                // Adicionar iluminação especial para o blueprint
                this.addBlueprintLighting();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Easing suave
                    const easedProgress = 1 - Math.pow(1 - progress, 3);
                    
                    // Interpolar posição da câmera
                    AppState.camera.position.x = originalPos.x + (targetPos.x - originalPos.x) * easedProgress;
                    AppState.camera.position.y = originalPos.y + (targetPos.y - originalPos.y) * easedProgress;
                    AppState.camera.position.z = originalPos.z + (targetPos.z - originalPos.z) * easedProgress;
                    
                    // Fazer câmera olhar para o centro do blueprint
                    AppState.camera.lookAt(
                        targetLookAt.x,
                        targetLookAt.y,
                        targetLookAt.z
                    );
                    
                    // Atualizar controles
                    AppState.controls.target.set(targetLookAt.x, targetLookAt.y, targetLookAt.z);
                    AppState.controls.update();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // Adicionar movimento de câmera orbital suave
                        this.addCameraOrbit();
                    }
                };
                
                animate();
            },

            addBlueprintLighting() {
                // Luz spotlight focada no blueprint
                const spotlight = new THREE.SpotLight(0x00ff88, 2, 100, Math.PI / 6, 0.5, 2);
                spotlight.position.set(0, 15, 5);
                spotlight.target.position.set(0, 2.5, 0);
                spotlight.castShadow = true;
                spotlight.shadow.mapSize.width = 2048;
                spotlight.shadow.mapSize.height = 2048;
                spotlight.name = 'blueprint-spotlight';
                
                AppState.scene.add(spotlight);
                AppState.scene.add(spotlight.target);
                
                // Luzes de acento coloridas
                const accentLights = [
                    { color: 0xff4757, position: [-8, 5, 3] },
                    { color: 0x3742fa, position: [8, 5, 3] },
                    { color: 0xffa502, position: [0, 5, -8] }
                ];
                
                accentLights.forEach((light, index) => {
                    const pointLight = new THREE.PointLight(light.color, 0.8, 20);
                    pointLight.position.set(...light.position);
                    pointLight.name = `accent-light-${index}`;
                    AppState.scene.add(pointLight);
                });
            },

            addCameraOrbit() {
                // Variáveis de controle da órbita
                let angle = 0;
                let isOrbiting = true;
                let orbitAnimationId = null;
                
                const radius = 12;
                const centerY = 8;
                const speed = 0.3;
                
                // Armazenar referência para poder parar depois
                AppState.cameraOrbit = {
                    isActive: true,
                    stop: () => {
                        isOrbiting = false;
                        if (orbitAnimationId) {
                            cancelAnimationFrame(orbitAnimationId);
                        }
                        // Reativar controles do usuário
                        AppState.controls.enabled = true;
                        console.log('Órbita da câmera parada - controles reativados');
                    }
                };
                
                // Desabilitar controles durante órbita automática
                AppState.controls.enabled = false;
                
                const orbit = () => {
                    if (!isOrbiting) return;
                    
                    angle += speed * 0.01;
                    
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    AppState.camera.position.x = x;
                    AppState.camera.position.z = z;
                    AppState.camera.position.y = centerY + Math.sin(angle * 0.5) * 2;
                    
                    AppState.camera.lookAt(0, 2.5, 0);
                    AppState.controls.target.set(0, 2.5, 0);
                    
                    // Parar automaticamente após 10 segundos (4π radianos)
                    if (angle < Math.PI * 4 && isOrbiting) {
                        orbitAnimationId = requestAnimationFrame(orbit);
                    } else {
                        // Parar e reativar controles
                        AppState.cameraOrbit.stop();
                    }
                };
                
                // Começar órbita após 1 segundo
                setTimeout(() => {
                    if (isOrbiting) {
                        console.log('Iniciando órbita da câmera - clique e arraste para parar');
                        this.showOrbitHint();
                        orbit();
                    }
                }, 1000);
                
                // Permitir que o usuário pare a órbita clicando e arrastando
                const stopOrbitOnInteraction = () => {
                    if (AppState.cameraOrbit && AppState.cameraOrbit.isActive) {
                        AppState.cameraOrbit.stop();
                        this.hideOrbitHint();
                        // Remover listeners após usar
                        AppState.renderer.domElement.removeEventListener('mousedown', stopOrbitOnInteraction);
                        AppState.renderer.domElement.removeEventListener('touchstart', stopOrbitOnInteraction);
                    }
                };
                
                // Adicionar listeners para parar órbita
                AppState.renderer.domElement.addEventListener('mousedown', stopOrbitOnInteraction);
                AppState.renderer.domElement.addEventListener('touchstart', stopOrbitOnInteraction);
            },

            showOrbitHint() {
                const hint = document.createElement('div');
                hint.id = 'orbit-hint';
                hint.style.cssText = `
                    position: fixed;
                    bottom: 30px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 255, 136, 0.9);
                    color: #000;
                    padding: 1rem 2rem;
                    border-radius: 25px;
                    font-size: 1rem;
                    font-weight: bold;
                    z-index: 150;
                    animation: fadeIn 0.5s ease;
                    border: 2px solid #00ff88;
                    box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
                    text-align: center;
                `;
                hint.innerHTML = `
                    🎥 Visualização Automática Ativa<br>
                    <span style="font-size: 0.9rem; opacity: 0.8;">Clique e arraste para retomar controle</span>
                `;
                
                document.body.appendChild(hint);
                
                // Auto-remover após 8 segundos
                setTimeout(() => {
                    this.hideOrbitHint();
                }, 8000);
            },

            hideOrbitHint() {
                const hint = document.getElementById('orbit-hint');
                if (hint) {
                    hint.style.opacity = '0';
                    hint.style.transition = 'opacity 0.5s ease';
                    setTimeout(() => {
                        if (hint.parentNode) {
                            hint.parentNode.removeChild(hint);
                        }
                    }, 500);
                }
            },

            create3DProjectStructure() {
                // Limpar objetos anteriores do blueprint
                const existingBlueprint = AppState.scene.getObjectByName('project-blueprint');
                if (existingBlueprint) {
                    AppState.scene.remove(existingBlueprint);
                }

                const blueprintGroup = new THREE.Group();
                blueprintGroup.name = 'project-blueprint';

                // Criar base holográfica para o blueprint
                this.createBlueprintBase(blueprintGroup);

                // Estrutura melhorada de pastas em 3D com informações detalhadas
                const folderStructure = [
                    { 
                        name: 'app/', 
                        position: [-4, 4, 0], 
                        color: 0x00ff88, 
                        type: 'folder', 
                        size: [2, 1.5, 2],
                        description: 'CÓDIGO PRINCIPAL',
                        function: 'Contém toda a lógica da aplicação Dash',
                        importance: 'Essencial - Coração do projeto'
                    },
                    { 
                        name: 'data/', 
                        position: [0, 4, 0], 
                        color: 0xff4757, 
                        type: 'folder', 
                        size: [2, 1.5, 2],
                        description: 'DADOS DO PROJETO',
                        function: 'Armazena datasets e arquivos de dados',
                        importance: 'Crítico - Base para visualizações'
                    },
                    { 
                        name: 'utils/', 
                        position: [4, 4, 0], 
                        color: 0x3742fa, 
                        type: 'folder', 
                        size: [2, 1.5, 2],
                        description: 'UTILITÁRIOS',
                        function: 'Funções auxiliares e helpers',
                        importance: 'Suporte - Facilita desenvolvimento'
                    },
                    { 
                        name: 'tests/', 
                        position: [-4, 1.5, 0], 
                        color: 0xffa502, 
                        type: 'folder', 
                        size: [2, 1.5, 2],
                        description: 'TESTES',
                        function: 'Testes automatizados da aplicação',
                        importance: 'Qualidade - Garante funcionamento'
                    },
                    { 
                        name: 'main.py', 
                        position: [0, 1.5, 0], 
                        color: 0x2ed573, 
                        type: 'file', 
                        size: [1.5, 2, 0.5],
                        description: 'ARQUIVO PRINCIPAL',
                        function: 'Ponto de entrada da aplicação',
                        importance: 'Fundamental - Inicia toda aplicação'
                    },
                    { 
                        name: 'pyproject.toml', 
                        position: [4, 1.5, 0], 
                        color: 0xff6348, 
                        type: 'file', 
                        size: [1.5, 2, 0.5],
                        description: 'CONFIGURAÇÃO',
                        function: 'Define dependências e configurações',
                        importance: 'Configuração - Padrão moderno Python'
                    }
                ];

                console.log('Criando estrutura 3D melhorada do projeto...');

                folderStructure.forEach((item, index) => {
                    try {
                        // Criar geometria com tamanhos personalizados
                        const geometry = new THREE.BoxGeometry(...item.size);
                        
                        // Material com efeitos holográficos melhorados
                        const material = new THREE.MeshPhongMaterial({
                            color: item.color,
                            transparent: true,
                            opacity: 0.7,
                            emissive: item.color,
                            emissiveIntensity: 0.15,
                            shininess: 100,
                            specular: 0x666666,
                            wireframe: false
                        });

                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(...item.position);
                        mesh.userData = { 
                            name: item.name, 
                            type: item.type, 
                            originalColor: item.color,
                            projectInfo: {
                                name: item.name,
                                description: item.description,
                                function: item.function,
                                importance: item.importance
                            }
                        };
                        mesh.name = `blueprint-item-${index}`;
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        
                        // Adicionar efeito de "respiração" para indicar interatividade
                        this.addBreathingEffect(mesh, index);
                        
                        // Adicionar borda wireframe
                        const wireframe = new THREE.WireframeGeometry(geometry);
                        const wireframeMaterial = new THREE.LineBasicMaterial({ 
                            color: item.color, 
                            transparent: true, 
                            opacity: 0.8,
                            linewidth: 2
                        });
                        const wireframeMesh = new THREE.LineSegments(wireframe, wireframeMaterial);
                        mesh.add(wireframeMesh);
                        
                        blueprintGroup.add(mesh);

                        // Criar label 3D melhorado
                        this.createImprovedLabel(item, index, blueprintGroup);

                        // Adicionar partículas ao redor dos objetos
                        this.createParticleEffect(item, blueprintGroup);

                        console.log(`Criado item melhorado: ${item.name} em posição`, item.position);
                    } catch (error) {
                        console.error(`Erro ao criar item ${item.name}:`, error);
                    }
                });

                // Adicionar conexões entre elementos
                this.createConnections(blueprintGroup);

                AppState.scene.add(blueprintGroup);
                console.log('Blueprint 3D melhorado adicionado à cena');

                // Sistema de hover para informações detalhadas
                this.setupHoverSystem();
                
                // Adicionar indicador visual de clicabilidade
                this.addClickabilityIndicator();
                
                // Dra. Turing apresenta o projeto
                this.drTuringPresentsProject();

                // Animar entrada dos objetos
                this.animateBlueprintEntrance(blueprintGroup);

                // Configurar interação com raycasting
                this.setupBlueprintInteraction();
            },

            createBlueprintBase(group) {
                // Base holográfica circular
                const baseGeometry = new THREE.CylinderGeometry(7, 7, 0.2, 32);
                const baseMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.2,
                    emissive: 0x00ff88,
                    emissiveIntensity: 0.1
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = -0.2;
                group.add(base);

                // Anéis holográficos
                for (let i = 1; i <= 3; i++) {
                    const ringGeometry = new THREE.RingGeometry(2 * i, 2 * i + 0.1, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ff88,
                        transparent: true,
                        opacity: 0.3 / i,
                        side: THREE.DoubleSide
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = -Math.PI / 2;
                    ring.position.y = 0.1;
                    group.add(ring);
                }
            },

            setupHoverSystem() {
                // Criar painel de informações
                const infoPanel = document.createElement('div');
                infoPanel.id = 'hover-info-panel';
                infoPanel.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, rgba(0, 255, 136, 0.95), rgba(0, 200, 255, 0.95));
                    color: #000;
                    padding: 20px;
                    border-radius: 15px;
                    border: 3px solid #00ff88;
                    font-family: Arial, sans-serif;
                    font-size: 16px;
                    max-width: 450px;
                    z-index: 1000;
                    display: none;
                    box-shadow: 0 0 25px rgba(0, 255, 136, 0.6);
                    backdrop-filter: blur(10px);
                `;
                document.body.appendChild(infoPanel);

                // Sistema de raycasting para hover e clique
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                
                const onMouseMove = (event) => {
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, this.camera);
                    const intersects = raycaster.intersectObjects(AppState.scene.children, true);
                    
                    let foundInfo = false;
                    for (let intersect of intersects) {
                        const object = intersect.object;
                        if (object.userData && object.userData.projectInfo) {
                            const info = object.userData.projectInfo;
                            infoPanel.innerHTML = `
                                <div style="border-bottom: 2px solid #000; margin-bottom: 15px; padding-bottom: 10px;">
                                    <h3 style="margin: 0; font-size: 24px; color: #000;">${info.name}</h3>
                                </div>
                                <div style="margin-bottom: 12px;">
                                    <strong style="color: #004d2a;">📂 Tipo:</strong><br>
                                    <span style="font-size: 18px;">${info.description}</span>
                                </div>
                                <div style="margin-bottom: 12px;">
                                    <strong style="color: #004d2a;">⚙️ Função:</strong><br>
                                    <span style="font-size: 16px;">${info.function}</span>
                                </div>
                                <div style="margin-bottom: 12px;">
                                    <strong style="color: #004d2a;">⭐ Importância:</strong><br>
                                    <span style="font-size: 16px; font-weight: bold;">${info.importance}</span>
                                </div>
                                <div style="border-top: 2px solid #000; padding-top: 10px; margin-top: 15px;">
                                    <strong style="color: #004d2a;">🖱️ Interação:</strong><br>
                                    <span style="font-size: 14px; color: #006d3a;">
                                        ${object.userData.type === 'folder' ? 
                                            '🔍 Clique para explorar esta pasta!' : 
                                            '📄 Clique para ver o conteúdo do arquivo!'}
                                    </span>
                                </div>
                            `;
                            infoPanel.style.display = 'block';
                            
                            // Cursor pointer para indicar clicável
                            document.body.style.cursor = 'pointer';
                            foundInfo = true;
                            break;
                        }
                    }
                    
                    if (!foundInfo) {
                        infoPanel.style.display = 'none';
                        document.body.style.cursor = 'default';
                    }
                };
                
                const onClick = (event) => {
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, this.camera);
                    const intersects = raycaster.intersectObjects(AppState.scene.children, true);
                    
                    for (let intersect of intersects) {
                        const object = intersect.object;
                        if (object.userData && object.userData.projectInfo) {
                            this.handleBlockClick(object);
                            break;
                        }
                    }
                };
                
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('click', onClick);
                
                // Instrução para o usuário
                const instructionPanel = document.createElement('div');
                instructionPanel.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 20px;
                    background: rgba(0, 255, 136, 0.9);
                    color: #000;
                    padding: 20px;
                    border-radius: 15px;
                    border: 3px solid #00ff88;
                    font-family: Arial, sans-serif;
                    font-size: 18px;
                    font-weight: bold;
                    z-index: 1000;
                    box-shadow: 0 0 25px rgba(0, 255, 136, 0.6);
                    max-width: 350px;
                `;
                instructionPanel.innerHTML = `
                    <div style="text-align: center; margin-bottom: 15px;">
                        🎯 <u>COMO INTERAGIR</u>
                    </div>
                    <div style="margin-bottom: 10px;">
                        🔍 <strong>Hover:</strong> Passe o mouse para ver detalhes
                    </div>
                    <div style="margin-bottom: 10px;">
                        🖱️ <strong>Clique:</strong> Clique nos blocos para explorar
                    </div>
                    <div style="margin-bottom: 10px;">
                        🎮 <strong>Câmera:</strong> Arraste para rotacionar a visão
                    </div>
                    <div style="font-size: 14px; color: #004d2a; text-align: center; margin-top: 15px;">
                        Experimente clicar em cada bloco! ✨
                    </div>
                `;
                document.body.appendChild(instructionPanel);
                
                // Remover instrução após alguns segundos
                setTimeout(() => {
                    instructionPanel.style.opacity = '0';
                    instructionPanel.style.transition = 'opacity 2s';
                    setTimeout(() => instructionPanel.remove(), 2000);
                }, 7000);
            },

            handleBlockClick(clickedObject) {
                const info = clickedObject.userData.projectInfo;
                console.log(`Clicou em: ${info.name}`);
                
                // Efeito visual de clique
                this.animateClickEffect(clickedObject);
                
                // Criar modal de detalhes expandidos
                this.showDetailModal(info);
                
                // Feedback sonoro visual (pulso de luz)
                this.createClickFeedback(clickedObject);

                // Reações contextuais da Dra. Turing
                this.drTuringReactToClick(info.name);
            },

            drTuringReactToClick(itemName) {
                // Reações específicas da Dra. Turing baseadas no item clicado
                const reactions = {
                    'app/': {
                        message: 'Excelente escolha! A pasta app/ é o coração da nossa aplicação. É aqui que organizamos toda a lógica do dashboard.',
                        gesture: 'explain'
                    },
                    'data/': {
                        message: 'Perfeito! Os dados são a alma de qualquer análise. Aqui ficará nosso dataset de doenças cardíacas.',
                        gesture: 'point'
                    },
                    'main.py': {
                        message: 'Muito bem! O main.py é nosso ponto de partida. É aqui que tudo começa quando executamos o dashboard.',
                        gesture: 'encourage'
                    },
                    'pyproject.toml': {
                        message: 'Ótima observação! O pyproject.toml é o arquivo de configuração moderno do Python. Muito mais elegante que o requirements.txt!',
                        gesture: 'think'
                    },
                    'utils/': {
                        message: 'Inteligente! As funções utilitárias tornam nosso código mais limpo e reutilizável.',
                        gesture: 'wave'
                    },
                    'tests/': {
                        message: 'Fantástico! Os testes garantem a qualidade do nosso código. Um desenvolvedor profissional sempre pensa em testes!',
                        gesture: 'encourage'
                    }
                };

                const reaction = reactions[itemName];
                if (reaction) {
                    // Fazer a Dra. Turing olhar para o item e reagir
                    setTimeout(() => {
                        this.drTuringSpeak3D(reaction.message, 6000);
                        
                        // Executar gesto contextual
                        setTimeout(() => {
                            if (AppState.drTuringAnimations && AppState.drTuringAnimations.performGesture) {
                                AppState.drTuringAnimations.performGesture(reaction.gesture);
                            }
                        }, 1500);
                    }, 500);
                } else {
                    // Reação genérica
                    const genericReactions = [
                        'Interessante! Você está explorando bem a arquitetura do projeto.',
                        'Muito bem! Cada componente tem sua importância na construção do dashboard.',
                        'Excelente curiosidade! Conhecer a estrutura é fundamental para o desenvolvimento.'
                    ];
                    
                    const randomReaction = genericReactions[Math.floor(Math.random() * genericReactions.length)];
                    setTimeout(() => {
                        this.drTuringSpeak3D(randomReaction, 4000);
                        
                        setTimeout(() => {
                            if (AppState.drTuringAnimations && AppState.drTuringAnimations.performGesture) {
                                AppState.drTuringAnimations.performGesture('wave');
                            }
                        }, 1000);
                    }, 500);
                }
            },

            animateClickEffect(object) {
                const originalScale = { x: object.scale.x, y: object.scale.y, z: object.scale.z };
                const targetScale = 1.3;
                const duration = 300;
                
                // Animação de "pulse" no clique
                let startTime = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    if (progress < 0.5) {
                        // Expandir
                        const scale = 1 + (targetScale - 1) * (progress * 2);
                        object.scale.set(scale, scale, scale);
                    } else {
                        // Contrair
                        const scale = targetScale - (targetScale - 1) * ((progress - 0.5) * 2);
                        object.scale.set(scale, scale, scale);
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        object.scale.set(originalScale.x, originalScale.y, originalScale.z);
                    }
                };
                animate();
            },

            createClickFeedback(object) {
                // Criar um ring de energia que se expande
                const ringGeometry = new THREE.RingGeometry(0.5, 1, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(object.position);
                ring.position.y += 3;
                ring.lookAt(this.camera.position);
                
                AppState.scene.add(ring);
                
                // Animação do ring
                let startTime = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / 1000;
                    
                    if (progress < 1) {
                        const scale = 1 + progress * 3;
                        ring.scale.set(scale, scale, scale);
                        ring.material.opacity = 0.8 * (1 - progress);
                        requestAnimationFrame(animate);
                    } else {
                        AppState.scene.remove(ring);
                    }
                };
                animate();
            },

            showDetailModal(info) {
                // Remover modal existente se houver
                const existingModal = document.getElementById('detail-modal');
                if (existingModal) existingModal.remove();
                
                const modal = document.createElement('div');
                modal.id = 'detail-modal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 2000;
                    backdrop-filter: blur(5px);
                `;
                
                const content = this.getDetailedContent(info);
                
                modal.innerHTML = `
                    <div style="
                        background: linear-gradient(135deg, rgba(0, 255, 136, 0.95), rgba(0, 200, 255, 0.9));
                        padding: 40px;
                        border-radius: 20px;
                        border: 4px solid #00ff88;
                        max-width: 600px;
                        max-height: 80vh;
                        overflow-y: auto;
                        box-shadow: 0 0 50px rgba(0, 255, 136, 0.8);
                        color: #000;
                        font-family: Arial, sans-serif;
                        position: relative;
                    ">
                        <button style="
                            position: absolute;
                            top: 15px;
                            right: 20px;
                            background: #ff4757;
                            color: white;
                            border: none;
                            width: 35px;
                            height: 35px;
                            border-radius: 50%;
                            font-size: 18px;
                            font-weight: bold;
                            cursor: pointer;
                            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                        " onclick="this.parentElement.parentElement.remove()">×</button>
                        ${content}
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Fechar modal clicando fora
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) modal.remove();
                });
                
                // Fechar com ESC
                const handleEsc = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', handleEsc);
                    }
                };
                document.addEventListener('keydown', handleEsc);
            },

            getDetailedContent(info) {
                const detailsMap = {
                    'app/': {
                        structure: [
                            '📄 __init__.py - Inicialização do módulo',
                            '📄 models.py - Modelos de dados',
                            '📄 views.py - Lógica de visualização',
                            '📄 routers.py - Definição de rotas',
                            '📁 templates/ - Templates HTML',
                            '📁 static/ - Arquivos CSS, JS, imagens'
                        ],
                        code: `# Exemplo de estrutura em models.py
import pandas as pd
from dash import html, dcc

class DataModel:
    def __init__(self):
        self.data = pd.read_csv('data/heart_disease.csv')
    
    def get_summary(self):
        return self.data.describe()`
                    },
                    'data/': {
                        structure: [
                            '📊 heart_disease.csv - Dataset principal',
                            '📄 preprocessing.py - Limpeza de dados',
                            '📁 raw/ - Dados brutos',
                            '📁 processed/ - Dados processados',
                            '📄 schema.json - Esquema dos dados'
                        ],
                        code: `# Exemplo de carregamento de dados
import pandas as pd

# Carregar dataset
df = pd.read_csv('heart_disease.csv')
print(f"Dataset: {df.shape[0]} linhas, {df.shape[1]} colunas")

# Estatísticas básicas
df.describe()`
                    },
                    'utils/': {
                        structure: [
                            '📄 helpers.py - Funções auxiliares',
                            '📄 validators.py - Validações',
                            '📄 formatters.py - Formatação de dados',
                            '📄 constants.py - Constantes do projeto'
                        ],
                        code: `# Exemplo de helper functions
def format_percentage(value):
    return f"{value:.1%}"

def validate_data(df):
    return not df.empty and len(df.columns) > 0

def clean_column_names(df):
    return df.columns.str.lower().str.replace(' ', '_')`
                    },
                    'tests/': {
                        structure: [
                            '📄 test_models.py - Testes dos modelos',
                            '📄 test_views.py - Testes das views',
                            '📄 test_utils.py - Testes utilitários',
                            '📄 conftest.py - Configuração pytest'
                        ],
                        code: `# Exemplo de teste
import pytest
import pandas as pd
from app.models import DataModel

def test_data_loading():
    model = DataModel()
    assert not model.data.empty
    assert len(model.data.columns) > 0

def test_summary_generation():
    model = DataModel()
    summary = model.get_summary()
    assert isinstance(summary, pd.DataFrame)`
                    },
                    'main.py': {
                        structure: [
                            '🚀 Ponto de entrada da aplicação',
                            '⚙️ Configuração do servidor Dash',
                            '🔗 Importação de todas as rotas',
                            '🎯 Inicialização da aplicação'
                        ],
                        code: `# main.py - Arquivo principal
from dash import Dash
from app.routers import register_routes
from app.models import DataModel

# Criar aplicação Dash
app = Dash(__name__)

# Registrar rotas
register_routes(app)

# Configurar dados
data_model = DataModel()

if __name__ == '__main__':
    app.run_server(debug=True, port=8050)`
                    },
                    'pyproject.toml': {
                        structure: [
                            '📦 Dependências do projeto',
                            '⚙️ Configurações de build',
                            '🔧 Scripts de automação',
                            '📋 Metadados do projeto'
                        ],
                        code: `# pyproject.toml
[project]
name = "dashboard-cardiaco"
version = "1.0.0"
dependencies = [
    "dash>=2.14.0",
    "dash-mantine-components>=0.12.0",
    "pandas>=2.0.0",
    "plotly>=5.15.0"
]

[project.scripts]
start = "python main.py"
test = "pytest tests/"
lint = "ruff check ."`
                    }
                };
                
                const details = detailsMap[info.name] || { structure: [], code: '' };
                
                return `
                    <h2 style="margin: 0 0 20px 0; color: #000; text-align: center; font-size: 28px;">
                        📁 ${info.name}
                    </h2>
                    
                    <div style="margin-bottom: 25px; padding: 20px; background: rgba(0,0,0,0.1); border-radius: 10px;">
                        <h3 style="margin: 0 0 10px 0; color: #004d2a;">📋 Descrição</h3>
                        <p style="margin: 0; font-size: 18px;">${info.description}</p>
                    </div>
                    
                    <div style="margin-bottom: 25px; padding: 20px; background: rgba(0,0,0,0.1); border-radius: 10px;">
                        <h3 style="margin: 0 0 15px 0; color: #004d2a;">🏗️ Estrutura Interna</h3>
                        ${details.structure.map(item => `<div style="margin: 8px 0; font-size: 16px;">• ${item}</div>`).join('')}
                    </div>
                    
                    ${details.code ? `
                    <div style="margin-bottom: 20px; padding: 20px; background: rgba(0,0,0,0.1); border-radius: 10px;">
                        <h3 style="margin: 0 0 15px 0; color: #004d2a;">💻 Exemplo de Código</h3>
                        <pre style="
                            background: #000; 
                            color: #00ff88; 
                            padding: 15px; 
                            border-radius: 8px; 
                            font-size: 14px; 
                            overflow-x: auto;
                            margin: 0;
                        ">${details.code}</pre>
                    </div>
                    ` : ''}
                    
                    <div style="text-align: center; margin-top: 30px;">
                        <div style="font-size: 14px; color: #004d2a;">
                            💡 Clique em outros blocos para explorar mais componentes!
                        </div>
                    </div>
                `;
            },

            addClickabilityIndicator() {
                // Criar indicador fixo na tela
                const clickIndicator = document.createElement('div');
                clickIndicator.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 255, 136, 0.9);
                    color: #000;
                    padding: 15px 25px;
                    border-radius: 25px;
                    border: 3px solid #00ff88;
                    font-family: Arial, sans-serif;
                    font-size: 16px;
                    font-weight: bold;
                    z-index: 1000;
                    box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
                    text-align: center;
                    animation: pulse 2s infinite;
                `;
                
                clickIndicator.innerHTML = `
                    🖱️ <span style="color: #004d2a;">CLIQUE NOS BLOCOS</span> para explorar! ✨
                `;
                
                // Adicionar animação CSS
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes pulse {
                        0% { transform: translateX(-50%) scale(1); box-shadow: 0 0 20px rgba(0, 255, 136, 0.6); }
                        50% { transform: translateX(-50%) scale(1.05); box-shadow: 0 0 30px rgba(0, 255, 136, 0.8); }
                        100% { transform: translateX(-50%) scale(1); box-shadow: 0 0 20px rgba(0, 255, 136, 0.6); }
                    }
                `;
                document.head.appendChild(style);
                document.body.appendChild(clickIndicator);
                
                // Remover após um tempo mas reaparecer periodicamente
                setTimeout(() => {
                    clickIndicator.style.opacity = '0';
                    clickIndicator.style.transition = 'opacity 1s';
                    setTimeout(() => {
                        clickIndicator.style.opacity = '0.8';
                        clickIndicator.innerHTML = '💡 Lembre-se: os blocos são interativos!';
                        setTimeout(() => {
                            clickIndicator.style.opacity = '0';
                            setTimeout(() => clickIndicator.remove(), 1000);
                        }, 3000);
                    }, 1000);
                }, 8000);
            },

            drTuringPresentsProject() {
                // Aguardar um momento antes da Dra. Turing falar sobre o projeto
                setTimeout(() => {
                    this.drTuringSpeak3D(`Excelente! Agora você pode ver a arquitetura 3D do nosso projeto. Cada bloco representa um componente essencial do dashboard que construiremos. Explore passando o mouse sobre os blocos e clique neles para descobrir sua função específica.`, 8000);
                    
                    // Gesto de apresentação
                    setTimeout(() => {
                        if (AppState.drTuringAnimations && AppState.drTuringAnimations.performGesture) {
                            AppState.drTuringAnimations.performGesture('welcome');
                        }
                    }, 1000);
                    
                    setTimeout(() => {
                        this.drTuringSpeak3D(`Nossa missão é analisar fatores de risco de doenças cardíacas usando dados reais do Kaggle. Vamos começar?`, 6000);
                        
                        // Gesto encorajador
                        setTimeout(() => {
                            if (AppState.drTuringAnimations && AppState.drTuringAnimations.performGesture) {
                                AppState.drTuringAnimations.performGesture('encourage');
                            }
                        }, 2000);
                    }, 9000);
                    
                    // Fazer a Dra. Turing apontar para o projeto (animação especial)
                    if (AppState.drTuringAnimations && AppState.drTuringAnimations.walkTo) {
                        setTimeout(() => {
                            // Caminhar para mais perto do projeto
                            AppState.drTuringAnimations.walkTo(-5, 2, 2000);
                        }, 16000);
                        
                        setTimeout(() => {
                            this.drTuringSpeak3D(`Cada pasta e arquivo tem uma função específica. Clique nos elementos para aprender mais!`, 4000);
                            
                            // Gesto de apontar para o projeto
                            setTimeout(() => {
                                if (AppState.drTuringAnimations && AppState.drTuringAnimations.performGesture) {
                                    AppState.drTuringAnimations.performGesture('point');
                                }
                            }, 1000);
                        }, 18000);
                    }
                }, 3000);
            },

            drTuringSpeak(message) {
                // Método legado - agora redireciona para o sistema 3D
                if (typeof message === 'string') {
                    // Extrair texto limpo do HTML
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = message;
                    const cleanText = tempDiv.textContent || tempDiv.innerText || message;
                    this.drTuringSpeak3D(cleanText, 6000);
                } else {
                    this.drTuringSpeak3D(message, 6000);
                }
            },

            addBreathingEffect(mesh, index) {
                // Efeito de "respiração" sutil para indicar interatividade
                const originalEmissiveIntensity = mesh.material.emissiveIntensity;
                let breathingDirection = 1;
                
                const breathe = () => {
                    if (mesh.material) {
                        mesh.material.emissiveIntensity += 0.003 * breathingDirection;
                        
                        if (mesh.material.emissiveIntensity >= 0.25) {
                            breathingDirection = -1;
                        } else if (mesh.material.emissiveIntensity <= 0.05) {
                            breathingDirection = 1;
                        }
                    }
                    
                    requestAnimationFrame(breathe);
                };
                
                // Começar cada objeto em momentos ligeiramente diferentes
                setTimeout(() => breathe(), index * 200);
            },

            createImprovedLabel(item, index, group) {
                // Canvas para texto 3D melhorado
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 640;
                canvas.height = 160;
                
                // Gradiente de fundo
                const gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, 'rgba(0, 255, 136, 0.95)');
                gradient.addColorStop(1, 'rgba(0, 200, 255, 0.95)');
                
                // Fundo com gradiente
                context.fillStyle = gradient;
                context.fillRect(10, 10, canvas.width - 20, canvas.height - 20);
                
                // Borda
                context.strokeStyle = '#00ff88';
                context.lineWidth = 6;
                context.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
                
                // Texto principal (nome do arquivo/pasta)
                context.fillStyle = '#000';
                context.font = 'bold 42px Arial';
                context.textAlign = 'center';
                context.fillText(item.name, canvas.width / 2, 60);
                
                // Subtítulo com descrição
                context.font = 'bold 28px Arial';
                let description = '';
                if (item.type === 'folder') {
                    if (item.name === 'app') description = 'CÓDIGO PRINCIPAL';
                    else if (item.name === 'data') description = 'DADOS DO PROJETO';
                    else if (item.name === 'utils') description = 'UTILITÁRIOS';
                    else if (item.name === 'tests') description = 'TESTES';
                    else if (item.name === 'static') description = 'ARQUIVOS ESTÁTICOS';
                    else description = 'PASTA';
                } else {
                    if (item.name === 'main.py') description = 'ARQUIVO PRINCIPAL';
                    else if (item.name === 'models.py') description = 'MODELOS DE DADOS';
                    else if (item.name === 'views.py') description = 'VISUALIZAÇÕES';
                    else if (item.name === 'routers.py') description = 'ROTAS';
                    else if (item.name === 'pyproject.toml') description = 'CONFIGURAÇÃO';
                    else if (item.name === '__init__.py') description = 'MÓDULO PYTHON';
                    else description = 'ARQUIVO';
                }
                context.fillText(description, canvas.width / 2, 110);
                
                // Sombra para melhor visibilidade
                context.shadowColor = '#000';
                context.shadowBlur = 8;
                context.shadowOffsetX = 2;
                context.shadowOffsetY = 2;

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                
                // Posicionamento melhorado - abaixo dos objetos com mais distância
                const labelY = item.type === 'folder' ? item.position[1] - 4.5 : item.position[1] - 5;
                sprite.position.set(item.position[0], labelY, item.position[2]);
                sprite.scale.set(4.5, 1.125, 1); // Maior para melhor visibilidade
                sprite.name = `blueprint-label-${index}`;
                
                // Sempre virado para a câmera
                sprite.lookAt = function() {
                    this.lookAt(AppState.scene.camera.position);
                };
                
                group.add(sprite);
            },

            createParticleEffect(item, group) {
                // Partículas flutuantes ao redor dos objetos
                const particleCount = 20;
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = item.position[0] + (Math.random() - 0.5) * 4;
                    positions[i * 3 + 1] = item.position[1] + (Math.random() - 0.5) * 4;
                    positions[i * 3 + 2] = item.position[2] + (Math.random() - 0.5) * 4;
                }
                
                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const particleMaterial = new THREE.PointsMaterial({
                    color: item.color,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                const particleSystem = new THREE.Points(particles, particleMaterial);
                particleSystem.name = `particles-${item.name}`;
                group.add(particleSystem);
            },

            createConnections(group) {
                // Conexões holográficas entre elementos relacionados
                const connections = [
                    { from: [-4, 4, 0], to: [0, 1.5, 0] }, // app -> main.py
                    { from: [0, 4, 0], to: [0, 1.5, 0] },  // data -> main.py
                    { from: [4, 4, 0], to: [0, 1.5, 0] },  // utils -> main.py
                    { from: [0, 1.5, 0], to: [4, 1.5, 0] } // main.py -> pyproject.toml
                ];
                
                connections.forEach((conn, index) => {
                    const points = [
                        new THREE.Vector3(...conn.from),
                        new THREE.Vector3(...conn.to)
                    ];
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({
                        color: 0x00ccff,
                        transparent: true,
                        opacity: 0.4,
                        linewidth: 2
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    line.name = `connection-${index}`;
                    group.add(line);
                });
            },

            animateBlueprintEntrance(blueprintGroup) {
                // Animar entrada dos objetos com efeitos melhorados
                blueprintGroup.children.forEach((child, index) => {
                    if (child.name && child.name.startsWith('blueprint-item-')) {
                        // Posição inicial (caindo do céu)
                        const originalY = child.position.y;
                        child.position.y = originalY + 10;
                        child.scale.set(0, 0, 0);
                        child.material.opacity = 0;
                        
                        // Animar com delay e efeitos
                        setTimeout(() => {
                            const startTime = Date.now();
                            const duration = 1200;
                            
                            const animate = () => {
                                const elapsed = Date.now() - startTime;
                                const progress = Math.min(elapsed / duration, 1);
                                
                                // Easing functions diferentes para Y e escala
                                const bounceProgress = this.easeOutBounce(progress);
                                const scaleProgress = this.easeOutElastic(progress);
                                
                                // Animação Y (queda com bounce)
                                child.position.y = (originalY + 10) + (originalY - (originalY + 10)) * bounceProgress;
                                
                                // Animação escala (elastic)
                                child.scale.set(scaleProgress, scaleProgress, scaleProgress);
                                
                                // Fade in
                                child.material.opacity = progress * 0.7;
                                
                                // Rotação durante entrada
                                child.rotation.y = (1 - progress) * Math.PI * 2;
                                
                                if (progress < 1) {
                                    requestAnimationFrame(animate);
                                } else {
                                    // Adicionar rotação idle
                                    this.addIdleAnimation(child);
                                }
                            };
                            
                            animate();
                        }, index * 300);
                    }
                    
                    // Animar partículas
                    if (child.name && child.name.startsWith('particles-')) {
                        this.animateParticles(child);
                    }
                });
            },

            easeOutBounce(t) {
                if (t < 1/2.75) {
                    return 7.5625 * t * t;
                } else if (t < 2/2.75) {
                    return 7.5625 * (t -= 1.5/2.75) * t + 0.75;
                } else if (t < 2.5/2.75) {
                    return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;
                } else {
                    return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;
                }
            },

            easeOutElastic(t) {
                if (t === 0) return 0;
                if (t === 1) return 1;
                const p = 0.3;
                const s = p / 4;
                return Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
            },

            addIdleAnimation(object) {
                // Animação de idle mais suave (flutuação menor)
                const startY = object.position.y;
                const startTime = Date.now();
                const floatAmount = 0.1; // Reduzido de 0.2 para 0.1
                const speed = 0.001; // Reduzido de 0.002 para 0.001
                
                const animate = () => {
                    const time = (Date.now() - startTime) * speed;
                    object.position.y = startY + Math.sin(time) * floatAmount;
                    object.rotation.y += 0.002; // Reduzido de 0.005 para 0.002
                    
                    requestAnimationFrame(animate);
                };
                
                animate();
            },

            animateParticles(particleSystem) {
                const startTime = Date.now();
                
                const animate = () => {
                    const time = (Date.now() - startTime) * 0.001;
                    const positions = particleSystem.geometry.attributes.position.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += Math.sin(time + i) * 0.01; // Y movement
                        positions[i] += Math.cos(time + i) * 0.005;     // X movement
                    }
                    
                    particleSystem.geometry.attributes.position.needsUpdate = true;
                    particleSystem.rotation.y += 0.01;
                    
                    requestAnimationFrame(animate);
                };
                
                animate();
            },

            setupBlueprintInteraction() {
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                // Remover listener anterior se existir
                if (this.blueprintClickHandler) {
                    AppState.renderer.domElement.removeEventListener('click', this.blueprintClickHandler);
                }
                if (this.blueprintMoveHandler) {
                    AppState.renderer.domElement.removeEventListener('mousemove', this.blueprintMoveHandler);
                }

                // Click handler
                this.blueprintClickHandler = (event) => {
                    const rect = AppState.renderer.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, AppState.camera);
                    
                    const blueprint = AppState.scene.getObjectByName('project-blueprint');
                    if (!blueprint) return;

                    const meshes = blueprint.children.filter(child => 
                        child.name && child.name.startsWith('blueprint-item-')
                    );
                    
                    const intersects = raycaster.intersectObjects(meshes);

                    if (intersects.length > 0) {
                        const clickedObject = intersects[0].object;
                        this.showItemDescription(clickedObject.userData);
                        this.animateClickEffect(clickedObject);
                    }
                };

                // Hover handler
                this.blueprintMoveHandler = (event) => {
                    const rect = AppState.renderer.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, AppState.camera);
                    
                    const blueprint = AppState.scene.getObjectByName('project-blueprint');
                    if (!blueprint) return;

                    const meshes = blueprint.children.filter(child => 
                        child.name && child.name.startsWith('blueprint-item-')
                    );
                    
                    const intersects = raycaster.intersectObjects(meshes);

                    // Reset all objects
                    meshes.forEach(mesh => {
                        mesh.material.emissiveIntensity = 0.15;
                        mesh.scale.set(1, 1, 1);
                        AppState.renderer.domElement.style.cursor = 'default';
                    });

                    // Highlight hovered object
                    if (intersects.length > 0) {
                        const hoveredObject = intersects[0].object;
                        hoveredObject.material.emissiveIntensity = 0.4;
                        hoveredObject.scale.set(1.1, 1.1, 1.1);
                        AppState.renderer.domElement.style.cursor = 'pointer';
                    }
                };

                AppState.renderer.domElement.addEventListener('click', this.blueprintClickHandler);
                AppState.renderer.domElement.addEventListener('mousemove', this.blueprintMoveHandler);
                console.log('Interação blueprint melhorada configurada');
            },

            animateClickEffect(object) {
                const originalScale = { x: object.scale.x, y: object.scale.y, z: object.scale.z };
                const startTime = Date.now();
                const duration = 300;
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / duration;
                    
                    if (progress < 0.5) {
                        // Expandir
                        const scale = 1 + (progress * 0.4);
                        object.scale.set(scale, scale, scale);
                    } else {
                        // Contrair
                        const scale = 1.2 - ((progress - 0.5) * 0.4);
                        object.scale.set(scale, scale, scale);
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        object.scale.set(originalScale.x, originalScale.y, originalScale.z);
                    }
                };
                
                animate();
            },

            showItemDescription(item) {
                if (!item || !item.name) {
                    console.log('Item inválido para mostrar descrição');
                    return;
                }

                const descriptions = {
                    'app/': '📁 Pasta principal do código da aplicação. Contém modelos, rotas, views e arquivos estáticos.',
                    'data/': '📊 Pasta para datasets e arquivos de dados. Aqui ficará nosso Heart Disease Dataset.',
                    'utils/': '🛠️ Funções utilitárias e helpers que podem ser reutilizados em diferentes partes do projeto.',
                    'tests/': '🧪 Testes automatizados para garantir a qualidade do código.',
                    'main.py': '🚀 Ponto de entrada da aplicação. Arquivo principal que inicia o servidor Dash.',
                    'pyproject.toml': '⚙️ Arquivo de configuração do projeto com dependências e metadados.'
                };

                const description = descriptions[item.name] || '📄 Componente do projeto.';
                
                // Remover painel anterior se existir
                const existingPanel = document.getElementById('blueprint-description');
                if (existingPanel) {
                    existingPanel.remove();
                }
                
                // Mostrar descrição em um mini-painel
                const miniPanel = document.createElement('div');
                miniPanel.id = 'blueprint-description';
                miniPanel.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 20px;
                    background: rgba(0, 255, 136, 0.95);
                    color: #000;
                    padding: 1rem;
                    border-radius: 8px;
                    max-width: 350px;
                    font-size: 0.9rem;
                    z-index: 200;
                    animation: fadeIn 0.3s ease;
                    box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
                    border: 2px solid #00ff88;
                    font-family: 'Segoe UI', sans-serif;
                `;
                miniPanel.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 0.5rem; font-size: 1rem;">
                        ${item.name}
                    </div>
                    <div>${description}</div>
                    <div style="text-align: right; margin-top: 0.5rem; font-size: 0.8rem; opacity: 0.7;">
                        Clique em outros elementos para explorar
                    </div>
                `;
                
                document.body.appendChild(miniPanel);
                
                // Auto-remover após 4 segundos
                setTimeout(() => {
                    if (miniPanel.parentNode) {
                        miniPanel.style.opacity = '0';
                        miniPanel.style.transition = 'opacity 0.3s ease';
                        setTimeout(() => {
                            if (miniPanel.parentNode) {
                                miniPanel.parentNode.removeChild(miniPanel);
                            }
                        }, 300);
                    }
                }, 4000);

                console.log(`Mostrando descrição para: ${item.name}`);
            },

            showUpcomingModules() {
                UISystem.showPanel(
                    'Próximos Módulos',
                    `
                        <div style="text-align: center; margin-bottom: 2rem;">
                            <div style="font-size: 3rem; margin-bottom: 1rem;">🚀</div>
                            <p><strong>Jornada de Desenvolvimento</strong></p>
                        </div>
                        <p>Aqui estão os próximos módulos que implementaremos:</p>
                        <ul>
                            <li><strong>Módulo 2:</strong> Núcleo do Servidor (<code>app = Dash(__name__)</code>)</li>
                            <li><strong>Módulo 3:</strong> Estrutura do Layout (dash_html_components)</li>
                            <li><strong>Módulo 4:</strong> Primeira Visualização (dash_core_components + Plotly)</li>
                            <li><strong>Módulo 5:</strong> Interatividade (callbacks)</li>
                            <li><strong>Módulo 6:</strong> Melhorias com Mantine (dash-mantine-components)</li>
                            <li><strong>Módulo 7:</strong> Refinamento (dash-chart-editor)</li>
                            <li><strong>Projeto Final:</strong> Dashboard Completo</li>
                        </ul>
                        <div style="background: rgba(0,255,136,0.1); padding: 1rem; border-radius: 5px; margin-top: 1rem;">
                            <p><em>🎯 Cada módulo adiciona uma nova funcionalidade ao dashboard e uma nova peça à arquitetura 3D!</em></p>
                        </div>
                    `,
                    [
                        { label: 'Explorar Ambiente', callback: () => UISystem.hidePanel() },
                        { label: 'Começar Módulo 2', callback: () => this.showComingSoon() }
                    ]
                );
            },

            showComingSoon() {
                UISystem.showPanel(
                    'Em Desenvolvimento',
                    `
                        <div style="text-align: center;">
                            <div style="font-size: 3rem; margin-bottom: 1rem;">⚡</div>
                            <p><strong>Módulos 2+ em Desenvolvimento</strong></p>
                            <p>Os próximos módulos estão sendo preparados e estarão disponíveis em breve!</p>
                            <p>Por enquanto, explore o ambiente 3D e familiarize-se com a estrutura do projeto.</p>
                        </div>
                    `,
                    [
                        { label: 'Fechar', callback: () => UISystem.hidePanel() }
                    ]
                );
            }
        };

        // Função principal de inicialização
        async function initializeApplication() {
            try {
                LoadingSystem.updateProgress(0, 'Inicializando sistema...');
                
                // Aguardar um pouco para mostrar a tela de carregamento
                await new Promise(resolve => setTimeout(resolve, 500));

                // Inicializar Three.js
                await ThreeJSSystem.init();

                // Inicializar Pyodide (pode falhar, mas continuamos)
                await PyodideSystem.init();

                // Marcar como inicializado
                AppState.isInitialized = true;
                LoadingSystem.updateProgress(5, 'Inicialização completa!');

                // Aguardar um pouco antes de ocultar loading
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Ocultar tela de carregamento
                LoadingSystem.hide();

                // Aguardar a transição terminar e mostrar primeiro módulo
                setTimeout(() => {
                    ModuleSystem.startFirstModule();
                }, 1500);

            } catch (error) {
                console.error('Erro durante inicialização:', error);
                LoadingSystem.updateProgress(5, 'Erro na inicialização, mas continuando...');
                
                // Mesmo com erro, tentar continuar
                setTimeout(() => {
                    LoadingSystem.hide();
                    setTimeout(() => {
                        UISystem.showPanel(
                            'Erro de Inicialização',
                            '<p>Houve um problema durante a inicialização, mas o ambiente básico está funcionando.</p>',
                            [{
                                label: 'Continuar Mesmo Assim',
                                callback: () => ModuleSystem.startFirstModule()
                            }]
                        );
                    }, 1500);
                }, 2000);
            }
        }

        // Funções globais para interação
        function nextStep() {
            ModuleSystem.nextStep();
        }

        function nextModule() {
            ModuleSystem.nextModule();
        }

        function load3DBlueprint() {
            ModuleSystem.load3DBlueprint();
        }

        // Configurar AutoTranslate quando a página carregar
        function setupTranslation() {
            // Detectar idioma do navegador
            const userLang = navigator.language || navigator.userLanguage;
            console.log('Idioma detectado:', userLang);
            
            // AutoTranslate.js será configurado aqui quando estiver totalmente carregado
            // Por enquanto, mantemos o conteúdo em português
        }

        // Inicializar aplicação quando a página carregar
        window.addEventListener('load', () => {
            setupTranslation();
            initializeApplication();
        });

        // Limpar recursos quando a página for fechada
        window.addEventListener('beforeunload', () => {
            if (AppState.animationId) {
                cancelAnimationFrame(AppState.animationId);
            }
        });
    </script>
</body>
</html>
